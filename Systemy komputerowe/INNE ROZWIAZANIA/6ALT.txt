# Ä†wiczenia 6, grupa cz. 10-12, 25. listopada 2021

###### tags: `PRW21` `Ä‡wiczenia` `pwit`

## Deklaracje

GotowoÅ›Ä‡ rozwiÄ…zania zadania naleÅ¼y wyraziÄ‡ poprzez postawienie X w odpowiedniej kolumnie! JeÅ›li poÅ¼Ä…dasz zreferowaÄ‡ dane zadanie (co najwyÅ¼ej jedno!) w trakcie dyskusji oznacz je znakiem ==X== na Å¼Ã³Å‚tym tle.

**UWAGA: TabelkÄ™ wolno edytowaÄ‡ tylko wtedy, gdy jest na zielonym tle!**


:::danger
|                        | 1     | 2   | 3   | 4   | 5   | 6   | 7   | 8   |
| ----------------------:| ----- | --- | --- | --- | --- | --- | --- | --- |
Dominik Budzki           |       |     |     |     |     |     |     |     |
PrzemysÅ‚aw Hoszowski     |   X   |  X  |  X  |  X  |     |  X  |     |     |
Dominik KomÅ‚a            |    X   |  X  |  X  |  X  |     |  X  |  X  |  X  |
Tomasz MrÃ³z              |       |     |     |     |     |     |     |     |
Mateusz Opala            |   X    |  X   |  X   |   X  |   X  |  X   |  X   |  X   |
Åukasz Pluta             |   X    |  X   |   ==X==  |   X  |     |  X   |   X  |  X   |
Antoni PokusiÅ„ski        |   X   |  X  |     |     |     |    X |     |     |
Szymon Rysz              |   X   |  X  |     |     |     |  X  |     |     |
Dominik Samorek          |       |     |     |     |     |     |     |     |
Mateusz SidÅ‚o            |    X  |  X  |  X  |  X  |     |     |     |     |
Mateusz Szwelengreber    |       |     |     |     |     |     |     |     |
Jan WaÅ„kowicz            |    X   |  X  |  X  |  X  |     |  X  |  X  |  X  |
MichaÅ‚ ZieliÅ„ski         |    X  |==X==|     |     |     |   X |   X |     |
:::




:::info
**Uwaga:** Po rozwiÄ…zaniu zadania naleÅ¼y zmieniÄ‡ kolor nagÅ‚Ã³wka na zielony.
:::

## Zadanie 1
:::success
Autor: Antoni PokusiÅ„ski
:::
### Bezpieczny
```
W1: --------<W.high><W.low.....>------
W2: ------<W.high.....><W.low>--------
```
Do rejestru moÅ¼e zostaÄ‡ w powyÅ¼szym przypadku zapisana gÃ³rna poÅ‚Ã³wka z W1 i dolna poÅ‚Ã³wka z W2. JeÅ›li wykonamy pÃ³Åºnej ```read()```, ktÃ³ry nie przeplata siÄ™ z innymi write'ami, to przeczytamy wartoÅ›Ä‡, ktÃ³ra nie pochodzi z ostatniego ```write()``` (dokÅ‚adniej - gÃ³rne bity pochodzÄ… z W2, a dolne z W1), co jest niezgodne z definicjÄ… rejestru typu *safe*.
### Regularny
```
W: ----<W.high><W.low>-------------------
R: --------<R.high.....><R.low.....>-----
```
JeÅ›li *R.high* zwrÃ³ci nam starÄ… wartoÅ›Ä‡ gÃ³rnego rejestru, a *R.low* zwrÃ³ci nowÄ… wartoÅ›Ä‡ dolnego rejestru, to dostaniemy "mieszanÄ…" wartoÅ›Ä‡, ktÃ³ra nie jest ani starÄ…, ani nowÄ… wartoÅ›ciÄ… caÅ‚ego 64-bitowego rejestru.
### Atomowy
Skoro rejestr nie jest regularny, to nie jest teÅ¼ atomowy.
## Zadanie 2
:::success
Autor: MichaÅ‚ ZieliÅ„ski
:::
### TreÅ›Ä‡
Algorytm Petersona speÅ‚nia warunki wzajemnego
wykluczania i niezagÅ‚odzenia, jeÅ›li zmienne flag[0], flag[1]
oraz victim oznaczajÄ… rejestry atomowe. Czy te warunki zostanÄ…
zachowane, jeÅ›li dla flag[0] i flag[1] uÅ¼yjemy rejestrÃ³w
regularnych?
### Algorytm Petersona
```= java
public void lock() {
 flag[i] = true; 
 victim  = i; 
 while (flag[j] && victim == i) {};
}
public void unlock() {
 flag[i] = false;
 }
```
### RozwiÄ…zanie
Zachowanie rejestrow atomowych i regularnych rozni sie w sytuacji, gdy na rejestrze jednoczesnie dokonywany jest zapis i odczyt. Sprawdzmy czy w takiej sytuacji wymienione wartosci zostaja zachowane. 
Do odczytu dochodzi tylko w linii 4. Niech watkiem dokomujacym odczytu jest A, a jednoczesnie zapisu dokonywac bedzie B. 
B zapisuje na linii 2
A odczytuje stara wartosc flag[B] falsz i wchodzi do sekcji krytycznej. B czeka (wzajemne wykluczanie) az A zmieni swoja flage w unlock po sekcji krytycznej (co sie wydarzy) (niezaglodzenie)
A odczytuje nowa wartosc i czeka. B ustawia jako ofiare siebie, wiec A przestaje czekac i wchodzi w sekcje krytyczna, a B czeka, bo flag[A] nie zostaÅ‚a zmienionia (wzajemne wykluczanie), dalszy przebieg jak wyzej (niezaglodzenie). 
B zapisuje na linii 7
A odczyta albo jedna iteracje wczesniej albo w takim samym momencie (jak przy rejestrach atomowych) flag[B] falsz i przejdzie do sekcji krytycznej (niezaglodzenie), ale B juz wyszlo z sekcji krytycznej (wzajemne wykluczanie).
## Zadanie 3
:::success
Autor: Åukasz Pluta
:::

WartoÅ›Ä‡ mapujemy na ciÄ…g bitÃ³w dÅ‚ugoÅ›ci O(log(m)) (tak jak zamieniamy liczbÄ™ na system binarny np.).

Mamy dwie tablice bitÃ³w o wielkoÅ›ci O(log(m)) bitÃ³w, wpisujemy do nich wartoÅ›ci na przemian (bity od lewej do prawej) i pamietamy ile zapisÃ³w juÅ¼ siÄ™ zakoÅ„czyÅ‚o caÅ‚kowicie(modulo 2). Przy readzie odczytujemy wartoÅ›Ä‡ z komÃ³rki w ktÃ³rej ostatnio zakoÅ„czyÅ‚ siÄ™ zapis (pierwszej lub drugiej zaleÅ¼nie od parzystoÅ›ci naszego licznika). Åatwo sprawdziÄ‡, Å¼e speÅ‚niamy w ten sposÃ³b 2 pierwsze warunki z zadania. 

## Zadanie 4
:::success
Autor: Mateusz SidÅ‚o
:::

:::success
**Twierdzenie**
dobry rejestr MRSW jest **regularny** *wtedy i tylko wtedy*, gdy dla kaÅ¼dego ciÄ…gu dostÄ™pÃ³w:
* dla kaÅ¼dego $i$ nie jest prawdÄ…, Å¼e $ğ‘…^i \rightarrow W^i$ (\*), oraz
* dla kaÅ¼dych $i$ oraz $j$ nie jest prawdÄ…, Å¼e $ğ‘Š^i \rightarrow W^j \rightarrow R^i$ (\*\*).
:::

:::info
**Definicja**
Rejestr nazwiemy **dobrym**, jeÅ›li dla kaÅ¼dego ciÄ…gu wspÃ³Å‚bieÅ¼nych dostÄ™pÃ³w do tego rejestru (zapisÃ³w i odczytÃ³w) kaÅ¼da wartoÅ›Ä‡ odczytana wystÄ™puje wÅ›rÃ³d wartoÅ›ci zapisanych (tzn. wartoÅ›ci odczytane nie biorÄ… siÄ™ â€œz powietrzaâ€).
:::

$\implies$

ZaÅ‚Ã³Å¼my, Å¼e mamy regularny rejestr MRSW. WeÅºmy dowolny ciÄ…g dstÄ™pÃ³w.

* **(\*)**

Nie moÅ¼e zajÅ›Ä‡ $R^i\rightarrow W^i$, bo rejestr jest regularny (w rejestrze nie znajduje siÄ™, nie jest do niego zapisywana $i$-ta wartoÅ›Ä‡.).

* **(\*\*)**

Nie moÅ¼e zajÅ›Ä‡ $W^i\rightarrow W^j \rightarrow R^i$, bo rejestr jest regularny (podczas gdy miaÅ‚oby zajÅ›Ä‡ $R^i$, $i$-tej wartoÅ›ci juÅ¼ w tym rejestrze nie ma).

$\impliedby$

ZaÅ‚Ã³Å¼my, Å¼e mamy dobry rejestr MRSW, taki Å¼e dla kaÅ¼dego ciÄ…gu dostÄ™pÃ³w zachodz: 
* dla kaÅ¼dego $i$ nie jest prawdÄ…, Å¼e $ğ‘…^i \rightarrow W^i$ (\*), oraz
* dla kaÅ¼dych $i$ oraz $j$ nie jest prawdÄ…, Å¼e $ğ‘Š^i \rightarrow W^j \rightarrow R^i$ (\*\*).

1. read() ($R^k$) jest niewspÃ³Å‚bieÅ¼ny z Å¼adnym write().

    Z (\*):  $W^k \rightarrow R^k$.
    Z (\*\*): nie istnieje takie $j$, Å¼e $ğ‘Š^k \rightarrow W^j \rightarrow R^k$.
    
    A zatem, $W^k$ jest ostatnik zapisem poprzedzajÄ…cym $R^k$.
    
    (jak reg dla sytuacji 1.)
    
2. read() ($R^x$) jest wspÃ³Å‚bieÅ¼ny z write()

    ![](https://i.imgur.com/IA7333C.png)
    
    $$
    x \leq k +l \text{, bo (*)}\\
    x \geq k \text{, bo (**)}
    $$
    
    (jak reg dla sytuacji 2.)
    
A zatem twierdzenie zachodzi.

## Zadanie 5
:::success
Autor Mateusz Opala
:::
Rozszerzmy definicjÄ™ ciÄ…gu W_i z zadania 4, wprowadzajÄ…c porzÄ…dek na zapisach w kolejnoÅ›ci zmian zawartoÅ›ci komÃ³rki po wykonaniu zapisu (czyli moment, w ktÃ³rym i-ty write faktycznie coÅ› zapisze do komÃ³rki). Innymi sÅ‚owy bierzemy przedziaÅ‚ odpowiedzialny za czas wywoÅ‚ania write i obcinamy koÅ„cÃ³wkÄ™, w ktÃ³rej wÄ…tek jest uÅ›piony albo nic nie robi. Za definicjÄ™ atomowego rejestru MRMW przyjmiemy to, Å¼e jest on linearyzowalny. PokaÅ¼emy najpierw implikacjÄ™ z lineryzowalnoÅ›ci w $*,**,***$:
1. $*$ jest oczywista, bo jak przedziaÅ‚y sÄ… rozÅ‚Ä…czne to pierwszy przedziaÅ‚ bÄ™dzie mieÄ‡ wczeÅ›niejszy punkt linearyzacji. Analogicznie $**$, bo jak przedziaÅ‚y sÄ… rozÅ‚Ä…czne to kolejnoÅ›c punktÃ³w linearyzacji jest taka sama jak przedziaÅ‚Ã³w. $***$ wynikajÄ… natychmiastowo z tego, Å¼e W_i -> R_i i z $**$
 
PokaÅ¼emy teraz implikacjÄ™ z $*,**,***$ w linearyzowalnoÅ›Ä‡:

2. Skonstruujemy porzÄ…dek na punktach linearyzacji pewnej historii H wywoÅ‚aÅ„ funkcji read,write. SpÃ³jrzmy najpierw na ciÄ…g W_0,W_1,...,W_n i nazwijmy ten ciÄ…g C. BÄ™dziemy teraz przechodziÄ‡ po kolejnych readach i read oznaczony jako R_i wstawimy tuÅ¼ przed writa $W_{i+1}$ lub na sam koniec do ciÄ…gu C w przypadku kiedy nie ma takiego writa. PokaÅ¼emy, Å¼e ciÄ…g C odpowiada zlinearyzowanej historii H. PatrzÄ…c jedynie na podciÄ…gi W_i i R_i osobno widzimy, Å¼e moÅ¼emy na nich wybraÄ‡ porzÄ…dek punktÃ³w linearyzacji wynikajÄ…cy z C odpowiednio z definicji W oraz z $***$. Wystarczy, wiÄ™c pokazaÄ‡, Å¼e moÅ¼emy dobraÄ‡ punkty linearyzacji tak, Å¼eby dla punktÃ³w linearyzacji byÅ‚o speÅ‚nione a) W_i -> R_i i R_i->$W_{i+1}$.
a) wynika bezpoÅ›rednio z $*$
b) ZaÅ‚Ã³Å¼my nie wprost, Å¼e $W_{i+1} -> R_i$ z a) mamy W_i -> R_i, czyli mamy W_i -> R_i -> $W_{i+1}$, ale z $**$ mamy natychmiastowÄ… sprzecznoÅ›Ä‡.

StÄ…d pokazaliÅ›my, Å¼e obie definicje sÄ… rÃ³wnowaÅ¼ne.

## Zadanie 6
:::success
Autor: PrzemysÅ‚aw Hoszowski
:::
```java=
public class RegMRSWRegister implements Register{
  RegBoolMRSWRegister[M] bit; // tutaj moÅ¼emy chcieÄ‡ zaznaczyÄ‡ 0 na poczÄ…tku
    
  public void write(int x) {
    this.bit[x].write(true);
    for (int i=x-1; i>=0; i--) 
      this.bit[i].write(false);
  }
    
  public int read() {
    for (int i=0; i < M; i++)
      if (this.bit[i].read())
        return i;
   }
}
```
Definicja regularnego rejestru:
![](https://i.imgur.com/11rIAgx.png)
Lemat: Read zawsze zwrÃ³ci wartoÅ›Ä‡
ZauwaÅ¼my, Å¼e usuniÄ™cie wartoÅ›ci poprzedza zapisanie wiÄ™kszej. Oznacza to, Å¼e najwiÄ™ksza zapisana wartoÅ›Ä‡ zawsze jest zapalona.

JeÅ›li podczas read nie wystÄ™puje write:
Wtedy wszystkie bity do ostatnio zapisanej wartoÅ›ci sÄ… zgaszone wiÄ™c zostanie ona przeczytana.

JeÅ›li read wystÄ™puje podczas write:
JeÅ›li zostanie zwrÃ³cona wartoÅ›Ä‡ mniejsza od x, to musiaÅ‚a ona zostaÄ‡ wprowadzona po ostatnim poprzedzajÄ…cym write, poniewaÅ¼ pola te zostaÅ‚y wyzerowane podczas jego zapisu. 
JeÅ›li zwrÃ³cone zostanie coÅ› wiÄ™kszego od $v^i$ (w tym x) dla dow. $i \in 0..k$ to $v^i$ musiaÅ‚ zostaÄ‡ usuniÄ™ty przez write - czyli wszystkie bity do $v^j$ - wartoÅ›ci wprowadzonej w miÄ™dzy czasie przez write, zostaÅ‚y wyzerowane. WiÄ™c zostanie zwrÃ³cona wartoÅ›Ä‡ $v^l$ dla $l \in 1..k$
## Zadanie 7
:::success
Autor: Jan WaÅ„kowicz
:::

W celu udowodnienia poprawnoÅ›ci naszego algorytmu udowodnijmy 3 podpunkty z zadania 5. 

1) Nie jest moÅ¼liwe, aby reader zwrÃ³ciÅ‚ wartoÅ›Ä‡, ktÃ³ra nie zostaÅ‚a jeszcze zapisana przez nikogo, wiÄ™c punkt jest speÅ‚niony. 

2) JeÅ›li $W^j$ znajduje siÄ™ w caÅ‚oÅ›ci po $W^i$, to wiemy, Å¼e na przekÄ…tnej nie znajduje siÄ™ juÅ¼ Å¼aden elemnt z $W^i$ (bo nadpisaliÅ›my je juÅ¼ jakimiÅ› wiÄ™kszymi). StÄ…d, jeÅ›li szukamy maxa w kolumnie podczas reada, nawet jeÅ›li znajdziemy gdzieÅ› wartoÅ›Ä‡ z $W^i$, to bÄ™dzie ona mniejsza od elementu na przekÄ…tnej i jej nie weÅºmiemy.

3) JeÅ›li $R^i$ znajduje siÄ™ przed $R^j$, znaleziony element w $R^i$ rozpropagowaliÅ›my juÅ¼ na caÅ‚y wiersz, wiÄ™c na pewno zostanie on (lub coÅ› wiÄ™kszego) znaleziony podczas przeszukiwania kolumny w $R^j$. StÄ…d $R^j >= R^i$.

## Zadanie 8
:::success
Autor: Dominik KomÅ‚a
:::

Nasz algorytm bÄ™dzie dziaÅ‚aÅ‚ w taki sposÃ³b, Å¼e stworzymy tablicÄ™, ktÃ³ra w kaÅ¼dej komÃ³rce ma atomowy rejestr MRSW, po jednej komÃ³rce na kaÅ¼dy wÄ…tek.

Aby zapisaÄ‡ do rejestru, wÄ…tek A czyta caÅ‚Ä… tablicÄ™, wybiera najwyÅ¼szy timestamp, dodaje 1 i zapisuje wartoÅ›Ä‡ z takim timestampem do swojej komÃ³rki.

Aby przeczytaÄ‡ rejestr, wÄ…tek czyta wszystkie komÃ³rki naszej tablicy i wybiera ten z najwiekszym timestampem. 

DziaÅ‚a to podobnie jak algorytm piekarni i tak jak tam, remisy w timestampach rozwiÄ…zujemy na korzyÅ›Ä‡ mniejszego THREAD.id().


DowÃ³d:

($*$)
![](https://i.imgur.com/Y0umtiD.png)

Åatwo moÅ¼na zauwaÅ¼yÄ‡, Å¼e wywoÅ‚anie read() nie moÅ¼e przeczytaÄ‡ wartoÅ›ci z naszej tablicy, dopÃ³ki nie zostanie ona tam zapisana. 

($**$)
![](https://i.imgur.com/a71Z6OF.png)

WeÅºmy sobie 2 wÄ…tki A i B. ZaÅ‚Ã³Å¼my, Å¼e wywoÅ‚anie metody write() przez A zostaÅ‚o wykonane caÅ‚kowicie przed wywoÅ‚aniem metody write() przez B. WeÅºmy takÅ¼e wÄ…tek C, ktÃ³rego wywoÅ‚anie metody read() zostaje wykonane caÅ‚kowicie po wywoÅ‚aniu write() przez B. Mamy dwa przypadki:
1) JeÅ›li A = B:
W takim przypadku zapis wykonany przez B po prostu nadpisze to, co wczeÅ›niej zapisaÅ‚ A i C przeczyta to co zapisaÅ‚ B
2) JeÅ›li A $\neq$ B:
W takim przypadku C widzi i to co zapisaÅ‚o A i B, ale B ma wyÅ¼szy timestamp, wiÄ™c C wybierze albo to co zapisaÅ‚o B, albo jeszcze coÅ› poÅºniejszego. W kaÅ¼dym razie napewno nie wybierze tego co zapisaÅ‚o A

($***$)
![](https://i.imgur.com/MeXVYYy.png)

WeÅºmy sobie dwa wÄ…tki A i B, takie, Å¼e $read_A()$ caÅ‚kowicie poprzedza $read_B()$. WeÅºmy takÅ¼e dwa wÄ…tki C i D, takie, Å¼e $write_C()$ jest przed $write_D()$. Chcemy pokazaÄ‡, Å¼e jeÅ›li A zwrÃ³ci wartoÅ›Ä‡ zapisanÄ… przez D, to B napewno nie zwrÃ³ci wartoÅ›ci zapisanej przez C.
Mamy dwa przypadki:
1) JeÅ›li $timestamp_C < timestamp_D$, wtedy A czyta po prostu D, a B przeczyta rÃ³wnieÅ¼ D lub coÅ› wyÅ¼szego. Napewno nie zwraca wartoÅ›ci zapisanej przez C.
2) JeÅ›li $timestamp_C = timestamp_D$, wtedy A i tak czyta D, poniewaÅ¼ $C < D$, a B jak w powyÅ¼szym punkcie zwrÃ³ci to co zapisaÅ‚o D lub coÅ› z jeszcze pÃ³Åºniejszym timestampem. Tak jak poprzednio napewno nie zwrÃ³ci wartoÅ›ci zapisanej przez C.

