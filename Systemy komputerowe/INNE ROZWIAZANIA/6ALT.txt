# ƒÜwiczenia 6, grupa cz. 10-12, 25. listopada 2021

###### tags: `PRW21` `ƒáwiczenia` `pwit`

## Deklaracje

Gotowo≈õƒá rozwiƒÖzania zadania nale≈ºy wyraziƒá poprzez postawienie X w odpowiedniej kolumnie! Je≈õli po≈ºƒÖdasz zreferowaƒá dane zadanie (co najwy≈ºej jedno!) w trakcie dyskusji oznacz je znakiem ==X== na ≈º√≥≈Çtym tle.

**UWAGA: Tabelkƒô wolno edytowaƒá tylko wtedy, gdy jest na zielonym tle!**


:::danger
|                        | 1     | 2   | 3   | 4   | 5   | 6   | 7   | 8   |
| ----------------------:| ----- | --- | --- | --- | --- | --- | --- | --- |
Dominik Budzki           |       |     |     |     |     |     |     |     |
Przemys≈Çaw Hoszowski     |   X   |  X  |  X  |  X  |     |  X  |     |     |
Dominik Kom≈Ça            |    X   |  X  |  X  |  X  |     |  X  |  X  |  X  |
Tomasz Mr√≥z              |       |     |     |     |     |     |     |     |
Mateusz Opala            |   X    |  X   |  X   |   X  |   X  |  X   |  X   |  X   |
≈Åukasz Pluta             |   X    |  X   |   ==X==  |   X  |     |  X   |   X  |  X   |
Antoni Pokusi≈Ñski        |   X   |  X  |     |     |     |    X |     |     |
Szymon Rysz              |   X   |  X  |     |     |     |  X  |     |     |
Dominik Samorek          |       |     |     |     |     |     |     |     |
Mateusz Sid≈Ço            |    X  |  X  |  X  |  X  |     |     |     |     |
Mateusz Szwelengreber    |       |     |     |     |     |     |     |     |
Jan Wa≈Ñkowicz            |    X   |  X  |  X  |  X  |     |  X  |  X  |  X  |
Micha≈Ç Zieli≈Ñski         |    X  |==X==|     |     |     |   X |   X |     |
:::




:::info
**Uwaga:** Po rozwiƒÖzaniu zadania nale≈ºy zmieniƒá kolor nag≈Ç√≥wka na zielony.
:::

## Zadanie 1
:::success
Autor: Antoni Pokusi≈Ñski
:::
### Bezpieczny
```
W1: --------<W.high><W.low.....>------
W2: ------<W.high.....><W.low>--------
```
Do rejestru mo≈ºe zostaƒá w powy≈ºszym przypadku zapisana g√≥rna po≈Ç√≥wka z W1 i dolna po≈Ç√≥wka z W2. Je≈õli wykonamy p√≥≈∫nej ```read()```, kt√≥ry nie przeplata siƒô z innymi write'ami, to przeczytamy warto≈õƒá, kt√≥ra nie pochodzi z ostatniego ```write()``` (dok≈Çadniej - g√≥rne bity pochodzƒÖ z W2, a dolne z W1), co jest niezgodne z definicjƒÖ rejestru typu *safe*.
### Regularny
```
W: ----<W.high><W.low>-------------------
R: --------<R.high.....><R.low.....>-----
```
Je≈õli *R.high* zwr√≥ci nam starƒÖ warto≈õƒá g√≥rnego rejestru, a *R.low* zwr√≥ci nowƒÖ warto≈õƒá dolnego rejestru, to dostaniemy "mieszanƒÖ" warto≈õƒá, kt√≥ra nie jest ani starƒÖ, ani nowƒÖ warto≈õciƒÖ ca≈Çego 64-bitowego rejestru.
### Atomowy
Skoro rejestr nie jest regularny, to nie jest te≈º atomowy.
## Zadanie 2
:::success
Autor: Micha≈Ç Zieli≈Ñski
:::
### Tre≈õƒá
Algorytm Petersona spe≈Çnia warunki wzajemnego
wykluczania i niezag≈Çodzenia, je≈õli zmienne flag[0], flag[1]
oraz victim oznaczajƒÖ rejestry atomowe. Czy te warunki zostanƒÖ
zachowane, je≈õli dla flag[0] i flag[1] u≈ºyjemy rejestr√≥w
regularnych?
### Algorytm Petersona
```= java
public void lock() {
 flag[i] = true; 
 victim  = i; 
 while (flag[j] && victim == i) {};
}
public void unlock() {
 flag[i] = false;
 }
```
### RozwiƒÖzanie
Zachowanie rejestrow atomowych i regularnych rozni sie w sytuacji, gdy na rejestrze jednoczesnie dokonywany jest zapis i odczyt. Sprawdzmy czy w takiej sytuacji wymienione wartosci zostaja zachowane. 
Do odczytu dochodzi tylko w linii 4. Niech watkiem dokomujacym odczytu jest A, a jednoczesnie zapisu dokonywac bedzie B. 
B zapisuje na linii 2
A odczytuje stara wartosc flag[B] falsz i wchodzi do sekcji krytycznej. B czeka (wzajemne wykluczanie) az A zmieni swoja flage w unlock po sekcji krytycznej (co sie wydarzy) (niezaglodzenie)
A odczytuje nowa wartosc i czeka. B ustawia jako ofiare siebie, wiec A przestaje czekac i wchodzi w sekcje krytyczna, a B czeka, bo flag[A] nie zosta≈Ça zmienionia (wzajemne wykluczanie), dalszy przebieg jak wyzej (niezaglodzenie). 
B zapisuje na linii 7
A odczyta albo jedna iteracje wczesniej albo w takim samym momencie (jak przy rejestrach atomowych) flag[B] falsz i przejdzie do sekcji krytycznej (niezaglodzenie), ale B juz wyszlo z sekcji krytycznej (wzajemne wykluczanie).
## Zadanie 3
:::success
Autor: ≈Åukasz Pluta
:::

Warto≈õƒá mapujemy na ciƒÖg bit√≥w d≈Çugo≈õci O(log(m)) (tak jak zamieniamy liczbƒô na system binarny np.).

Mamy dwie tablice bit√≥w o wielko≈õci O(log(m)) bit√≥w, wpisujemy do nich warto≈õci na przemian (bity od lewej do prawej) i pamietamy ile zapis√≥w ju≈º siƒô zako≈Ñczy≈Ço ca≈Çkowicie(modulo 2). Przy readzie odczytujemy warto≈õƒá z kom√≥rki w kt√≥rej ostatnio zako≈Ñczy≈Ç siƒô zapis (pierwszej lub drugiej zale≈ºnie od parzysto≈õci naszego licznika). ≈Åatwo sprawdziƒá, ≈ºe spe≈Çniamy w ten spos√≥b 2 pierwsze warunki z zadania. 

## Zadanie 4
:::success
Autor: Mateusz Sid≈Ço
:::

:::success
**Twierdzenie**
dobry rejestr MRSW jest **regularny** *wtedy i tylko wtedy*, gdy dla ka≈ºdego ciƒÖgu dostƒôp√≥w:
* dla ka≈ºdego $i$ nie jest prawdƒÖ, ≈ºe $ùëÖ^i \rightarrow W^i$ (\*), oraz
* dla ka≈ºdych $i$ oraz $j$ nie jest prawdƒÖ, ≈ºe $ùëä^i \rightarrow W^j \rightarrow R^i$ (\*\*).
:::

:::info
**Definicja**
Rejestr nazwiemy **dobrym**, je≈õli dla ka≈ºdego ciƒÖgu wsp√≥≈Çbie≈ºnych dostƒôp√≥w do tego rejestru (zapis√≥w i odczyt√≥w) ka≈ºda warto≈õƒá odczytana wystƒôpuje w≈õr√≥d warto≈õci zapisanych (tzn. warto≈õci odczytane nie biorƒÖ siƒô ‚Äúz powietrza‚Äù).
:::

$\implies$

Za≈Ç√≥≈ºmy, ≈ºe mamy regularny rejestr MRSW. We≈∫my dowolny ciƒÖg dstƒôp√≥w.

* **(\*)**

Nie mo≈ºe zaj≈õƒá $R^i\rightarrow W^i$, bo rejestr jest regularny (w rejestrze nie znajduje siƒô, nie jest do niego zapisywana $i$-ta warto≈õƒá.).

* **(\*\*)**

Nie mo≈ºe zaj≈õƒá $W^i\rightarrow W^j \rightarrow R^i$, bo rejestr jest regularny (podczas gdy mia≈Çoby zaj≈õƒá $R^i$, $i$-tej warto≈õci ju≈º w tym rejestrze nie ma).

$\impliedby$

Za≈Ç√≥≈ºmy, ≈ºe mamy dobry rejestr MRSW, taki ≈ºe dla ka≈ºdego ciƒÖgu dostƒôp√≥w zachodz: 
* dla ka≈ºdego $i$ nie jest prawdƒÖ, ≈ºe $ùëÖ^i \rightarrow W^i$ (\*), oraz
* dla ka≈ºdych $i$ oraz $j$ nie jest prawdƒÖ, ≈ºe $ùëä^i \rightarrow W^j \rightarrow R^i$ (\*\*).

1. read() ($R^k$) jest niewsp√≥≈Çbie≈ºny z ≈ºadnym write().

    Z (\*):  $W^k \rightarrow R^k$.
    Z (\*\*): nie istnieje takie $j$, ≈ºe $ùëä^k \rightarrow W^j \rightarrow R^k$.
    
    A zatem, $W^k$ jest ostatnik zapisem poprzedzajƒÖcym $R^k$.
    
    (jak reg dla sytuacji 1.)
    
2. read() ($R^x$) jest wsp√≥≈Çbie≈ºny z write()

    ![](https://i.imgur.com/IA7333C.png)
    
    $$
    x \leq k +l \text{, bo (*)}\\
    x \geq k \text{, bo (**)}
    $$
    
    (jak reg dla sytuacji 2.)
    
A zatem twierdzenie zachodzi.

## Zadanie 5
:::success
Autor Mateusz Opala
:::
Rozszerzmy definicjƒô ciƒÖgu W_i z zadania 4, wprowadzajƒÖc porzƒÖdek na zapisach w kolejno≈õci zmian zawarto≈õci kom√≥rki po wykonaniu zapisu (czyli moment, w kt√≥rym i-ty write faktycznie co≈õ zapisze do kom√≥rki). Innymi s≈Çowy bierzemy przedzia≈Ç odpowiedzialny za czas wywo≈Çania write i obcinamy ko≈Ñc√≥wkƒô, w kt√≥rej wƒÖtek jest u≈õpiony albo nic nie robi. Za definicjƒô atomowego rejestru MRMW przyjmiemy to, ≈ºe jest on linearyzowalny. Poka≈ºemy najpierw implikacjƒô z lineryzowalno≈õci w $*,**,***$:
1. $*$ jest oczywista, bo jak przedzia≈Çy sƒÖ roz≈ÇƒÖczne to pierwszy przedzia≈Ç bƒôdzie mieƒá wcze≈õniejszy punkt linearyzacji. Analogicznie $**$, bo jak przedzia≈Çy sƒÖ roz≈ÇƒÖczne to kolejno≈õc punkt√≥w linearyzacji jest taka sama jak przedzia≈Ç√≥w. $***$ wynikajƒÖ natychmiastowo z tego, ≈ºe W_i -> R_i i z $**$
 
Poka≈ºemy teraz implikacjƒô z $*,**,***$ w linearyzowalno≈õƒá:

2. Skonstruujemy porzƒÖdek na punktach linearyzacji pewnej historii H wywo≈Ça≈Ñ funkcji read,write. Sp√≥jrzmy najpierw na ciƒÖg W_0,W_1,...,W_n i nazwijmy ten ciƒÖg C. Bƒôdziemy teraz przechodziƒá po kolejnych readach i read oznaczony jako R_i wstawimy tu≈º przed writa $W_{i+1}$ lub na sam koniec do ciƒÖgu C w przypadku kiedy nie ma takiego writa. Poka≈ºemy, ≈ºe ciƒÖg C odpowiada zlinearyzowanej historii H. PatrzƒÖc jedynie na podciƒÖgi W_i i R_i osobno widzimy, ≈ºe mo≈ºemy na nich wybraƒá porzƒÖdek punkt√≥w linearyzacji wynikajƒÖcy z C odpowiednio z definicji W oraz z $***$. Wystarczy, wiƒôc pokazaƒá, ≈ºe mo≈ºemy dobraƒá punkty linearyzacji tak, ≈ºeby dla punkt√≥w linearyzacji by≈Ço spe≈Çnione a) W_i -> R_i i R_i->$W_{i+1}$.
a) wynika bezpo≈õrednio z $*$
b) Za≈Ç√≥≈ºmy nie wprost, ≈ºe $W_{i+1} -> R_i$ z a) mamy W_i -> R_i, czyli mamy W_i -> R_i -> $W_{i+1}$, ale z $**$ mamy natychmiastowƒÖ sprzeczno≈õƒá.

StƒÖd pokazali≈õmy, ≈ºe obie definicje sƒÖ r√≥wnowa≈ºne.

## Zadanie 6
:::success
Autor: Przemys≈Çaw Hoszowski
:::
```java=
public class RegMRSWRegister implements Register{
  RegBoolMRSWRegister[M] bit; // tutaj mo≈ºemy chcieƒá zaznaczyƒá 0 na poczƒÖtku
    
  public void write(int x) {
    this.bit[x].write(true);
    for (int i=x-1; i>=0; i--) 
      this.bit[i].write(false);
  }
    
  public int read() {
    for (int i=0; i < M; i++)
      if (this.bit[i].read())
        return i;
   }
}
```
Definicja regularnego rejestru:
![](https://i.imgur.com/11rIAgx.png)
Lemat: Read zawsze zwr√≥ci warto≈õƒá
Zauwa≈ºmy, ≈ºe usuniƒôcie warto≈õci poprzedza zapisanie wiƒôkszej. Oznacza to, ≈ºe najwiƒôksza zapisana warto≈õƒá zawsze jest zapalona.

Je≈õli podczas read nie wystƒôpuje write:
Wtedy wszystkie bity do ostatnio zapisanej warto≈õci sƒÖ zgaszone wiƒôc zostanie ona przeczytana.

Je≈õli read wystƒôpuje podczas write:
Je≈õli zostanie zwr√≥cona warto≈õƒá mniejsza od x, to musia≈Ça ona zostaƒá wprowadzona po ostatnim poprzedzajƒÖcym write, poniewa≈º pola te zosta≈Çy wyzerowane podczas jego zapisu. 
Je≈õli zwr√≥cone zostanie co≈õ wiƒôkszego od $v^i$ (w tym x) dla dow. $i \in 0..k$ to $v^i$ musia≈Ç zostaƒá usuniƒôty przez write - czyli wszystkie bity do $v^j$ - warto≈õci wprowadzonej w miƒôdzy czasie przez write, zosta≈Çy wyzerowane. Wiƒôc zostanie zwr√≥cona warto≈õƒá $v^l$ dla $l \in 1..k$
## Zadanie 7
:::success
Autor: Jan Wa≈Ñkowicz
:::

W celu udowodnienia poprawno≈õci naszego algorytmu udowodnijmy 3 podpunkty z zadania 5. 

1) Nie jest mo≈ºliwe, aby reader zwr√≥ci≈Ç warto≈õƒá, kt√≥ra nie zosta≈Ça jeszcze zapisana przez nikogo, wiƒôc punkt jest spe≈Çniony. 

2) Je≈õli $W^j$ znajduje siƒô w ca≈Ço≈õci po $W^i$, to wiemy, ≈ºe na przekƒÖtnej nie znajduje siƒô ju≈º ≈ºaden elemnt z $W^i$ (bo nadpisali≈õmy je ju≈º jakimi≈õ wiƒôkszymi). StƒÖd, je≈õli szukamy maxa w kolumnie podczas reada, nawet je≈õli znajdziemy gdzie≈õ warto≈õƒá z $W^i$, to bƒôdzie ona mniejsza od elementu na przekƒÖtnej i jej nie we≈∫miemy.

3) Je≈õli $R^i$ znajduje siƒô przed $R^j$, znaleziony element w $R^i$ rozpropagowali≈õmy ju≈º na ca≈Çy wiersz, wiƒôc na pewno zostanie on (lub co≈õ wiƒôkszego) znaleziony podczas przeszukiwania kolumny w $R^j$. StƒÖd $R^j >= R^i$.

## Zadanie 8
:::success
Autor: Dominik Kom≈Ça
:::

Nasz algorytm bƒôdzie dzia≈Ça≈Ç w taki spos√≥b, ≈ºe stworzymy tablicƒô, kt√≥ra w ka≈ºdej kom√≥rce ma atomowy rejestr MRSW, po jednej kom√≥rce na ka≈ºdy wƒÖtek.

Aby zapisaƒá do rejestru, wƒÖtek A czyta ca≈ÇƒÖ tablicƒô, wybiera najwy≈ºszy timestamp, dodaje 1 i zapisuje warto≈õƒá z takim timestampem do swojej kom√≥rki.

Aby przeczytaƒá rejestr, wƒÖtek czyta wszystkie kom√≥rki naszej tablicy i wybiera ten z najwiekszym timestampem. 

Dzia≈Ça to podobnie jak algorytm piekarni i tak jak tam, remisy w timestampach rozwiƒÖzujemy na korzy≈õƒá mniejszego THREAD.id().


Dow√≥d:

($*$)
![](https://i.imgur.com/Y0umtiD.png)

≈Åatwo mo≈ºna zauwa≈ºyƒá, ≈ºe wywo≈Çanie read() nie mo≈ºe przeczytaƒá warto≈õci z naszej tablicy, dop√≥ki nie zostanie ona tam zapisana. 

($**$)
![](https://i.imgur.com/a71Z6OF.png)

We≈∫my sobie 2 wƒÖtki A i B. Za≈Ç√≥≈ºmy, ≈ºe wywo≈Çanie metody write() przez A zosta≈Ço wykonane ca≈Çkowicie przed wywo≈Çaniem metody write() przez B. We≈∫my tak≈ºe wƒÖtek C, kt√≥rego wywo≈Çanie metody read() zostaje wykonane ca≈Çkowicie po wywo≈Çaniu write() przez B. Mamy dwa przypadki:
1) Je≈õli A = B:
W takim przypadku zapis wykonany przez B po prostu nadpisze to, co wcze≈õniej zapisa≈Ç A i C przeczyta to co zapisa≈Ç B
2) Je≈õli A $\neq$ B:
W takim przypadku C widzi i to co zapisa≈Ço A i B, ale B ma wy≈ºszy timestamp, wiƒôc C wybierze albo to co zapisa≈Ço B, albo jeszcze co≈õ po≈∫niejszego. W ka≈ºdym razie napewno nie wybierze tego co zapisa≈Ço A

($***$)
![](https://i.imgur.com/MeXVYYy.png)

We≈∫my sobie dwa wƒÖtki A i B, takie, ≈ºe $read_A()$ ca≈Çkowicie poprzedza $read_B()$. We≈∫my tak≈ºe dwa wƒÖtki C i D, takie, ≈ºe $write_C()$ jest przed $write_D()$. Chcemy pokazaƒá, ≈ºe je≈õli A zwr√≥ci warto≈õƒá zapisanƒÖ przez D, to B napewno nie zwr√≥ci warto≈õci zapisanej przez C.
Mamy dwa przypadki:
1) Je≈õli $timestamp_C < timestamp_D$, wtedy A czyta po prostu D, a B przeczyta r√≥wnie≈º D lub co≈õ wy≈ºszego. Napewno nie zwraca warto≈õci zapisanej przez C.
2) Je≈õli $timestamp_C = timestamp_D$, wtedy A i tak czyta D, poniewa≈º $C < D$, a B jak w powy≈ºszym punkcie zwr√≥ci to co zapisa≈Ço D lub co≈õ z jeszcze p√≥≈∫niejszym timestampem. Tak jak poprzednio napewno nie zwr√≥ci warto≈õci zapisanej przez C.

