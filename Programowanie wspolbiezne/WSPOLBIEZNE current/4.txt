# L4 GRUPA 1

## Zadanie 1
:::success
Autor:	Kamil Galik	
:::
```java=
class Filter implements Lock {
    int[] level;
    int[] victim;
    public Filter(int n) {
        level = new int[n];
        victim = new int[n]; // use 1..n-1
        for (int i = 0; i < n; i++) {
            level[i] = 0;
        }
    }
    
    public void lock() {
        int me = ThreadID.get(); // returns 0..n-1
        for (int i = 1; i < n; i++) { // attempt to enter level i
            level[me] = i;
            victim[i] = me;
            // spin while conflicts exist
            while (( âˆƒ k != me) (level[k] >= i && victim[i] == me)) {};
        }
    }
    
    public void unlock() {
        int me = ThreadID.get();
        level[me] = 0;
    }
}
```
*Fakt:* kaÅ¼dy wÄ…tek wykonujÄ…cy metodÄ™ lock() znajduje siÄ™ na jednym z $n-1$ poziomÃ³w, z ktÃ³rych ostatni oznacza zajÄ™cie zamka. Na poziomie $n - i$ znajduje siÄ™ jednoczeÅ›nie co najwyÅ¼ej $i$ wÄ…tkÃ³w.

*Uzasadnienie*: 
Zrobimy indukcjÄ™ po poziomach. Na poziomie 0 trywialnie znajduje siÄ™ n wÄ…tkÃ³w. ZaÅ‚Ã³Å¼my indukcyjnie, Å¼e na poziomie $j - 1$ (dla $j > 0$) znajduje siÄ™ co najwyÅ¼ej $n - j + 1$ wÄ…tkÃ³w. PokaÅ¼emy, Å¼e na poziom $j$ nie przejdzie przynajmniej 1 wÄ…tek.

ZaÅ‚Ã³Å¼my nie wprost, Å¼e na poziomie $j$ znajduje siÄ™ $n - j + 1$ wÄ…tkÃ³w.
Niech $A$ bÄ™dzie ostatnim wÄ…tkiem, ktÃ³ry zapisaÅ‚ zmiennÄ… victim na poziomie $j$.
Wtedy dla dowolnego wÄ…tku $B$ na poziomie $j$: $Write_B(victim[j] = B)\rightarrow Write_A(victim[j] = A)$
Z kodu widzimy, Å¼e: $Write_B(level[B] = j)\rightarrow Write_B(victim[j] = B)\rightarrow Write_A(victim[j] = A)\rightarrow Read_A(level[B])$
WÄ…tek $A$ staje siÄ™ w takim razie ofiarÄ… i nie mÃ³gÅ‚ wejÅ›Ä‡ na poziom $j$, poniewaÅ¼ dla kaÅ¼dego wÄ…tku $B$: $level[B] >= j$ co jest sprzeczne z tym, Å¼e A weszÅ‚o na poziom $j$.

**Wzajemne wykluczanie:** WÄ…tek wchodzi w sekcjÄ™ krytycznÄ…, gdy znajduje siÄ™ na (n-1)-szym poziomie. Niech i = 1. Z faktu przytoczonego powyÅ¼ej wiemy, Å¼e na poziomie n-1 znajduje siÄ™ co najwyÅ¼ej 1 wÄ…tek, czyli zachodzi wÅ‚asnoÅ›Ä‡ wzajemnego wykluczania.
## Zadanie 2
:::success
Autor:	Wojciech PokÃ³j	
:::

![](https://i.imgur.com/TAvTyZS.png)

D-d przez odwrÃ³conÄ… indukcjÄ™ po poziomach

Podstawa indukcji: 
Poziom n - 1 posiada tÄ™ wÅ‚asnoÅ›Ä‡ poniewaÅ¼ jak pokazaliÅ›my, moÅ¼e tam dotrzeÄ‡ conajwyÅ¼ej 1 wÄ…tek, wiÄ™c zagÅ‚odzenie na tym poziomie nie wystÄ™puje

Krok:
ZaÅ‚Ã³Å¼my nie wprost Å¼e A utknÄ…Å‚ na poziomie i. Z zaÅ‚oÅ¼enie indukcyjnego, po jakimÅ› czasie na wyÅ¼szych poziomach nie bÄ™dzie Å¼adnych wÄ…tkÃ³w. Po tym jak A ustawi level[A] = i, wtedy wszystkie wÄ…tki oczekujÄ…ce na niÅ¼szych poziomach nigdy nie wejdÄ… na poziom i-ty, poniewaÅ¼ bÄ™dÄ… zblokowane przez tÄ™ wartoÅ›Ä‡.

PoniewaÅ¼ A bÄ™dzie jedynym wÄ…tkiem ktÃ³ry bÄ™dzie konkurowaÄ‡ na poziomie i oraz wyÅ¼szych wiÄ™c dostanie w koÅ„cu dostÄ™p na poziom wyÅ¼ej.

Zblokowanie nie nastÄ…pi teÅ¼ gdy 2 wÄ…tki A i B utknÄ… na jednym poziomie. Jeden wÄ…tek na pewno przejdzie wyÅ¼ej, poniewaÅ¼ victim nie moÅ¼e jednoczeÅ›nie wskazywaÄ‡ na 2 wartoÅ›ci.

Na mocy indukcji algorytm nie posiada wÅ‚asnoci zagÅ‚odzenia

MoÅ¼na stÄ…d teÅ¼ wywnioskowaÄ‡ Å¼e algorytm siÄ™ nigdy nie zablokuje, poniewaÅ¼ w koÅ„cu zwolniÄ… siÄ™ poziomy wyÅ¼ej wiÄ™c kolejka moÅ¼e zawsze byÄ‡ kontynuowana

## Zadanie 3
:::success
Autor:	Julia Matuszewska	
:::
![](https://i.imgur.com/7ED96PO.png)
```java=
class Filter implements Lock  {
    //informacje o poziomie kaÅ¼dego wÄ…tku
    int[] level;
    //informacje o wÄ…tku ktÃ³ry jako ostatni zgÅ‚osiÅ‚ chÄ™Ä‡ zdobycia poziomu
    int[] victim;
    public Filter(int n) {
        level = new int[n];
        victim = new int[n]; // use 1..n-1
        for (int i = 0; i < n; i++) {
            level[i] = 0;
        }
    }
    public void lock() {
        int me = ThreadID.get(); // returns 0..n-1
        for (int i = 1; i < n; i++) { // attempt to enter level i
            level[me] = i;
            victim[i] = me;
            // spin while conflicts exist
            // inny wÄ…tek jest na wyÅ¼szym lub rÃ³wnym poziomie
            // i nasz wÄ…tek jako ostatni zgÅ‚osiÅ‚ chÄ™Ä‡ zdobycia poziomu
            while (( âˆƒ k != me) (level[k] >= i && victim[i] == me)) {};
        }
    }
    public void unlock() {
        int me = ThreadID.get();
        level[me] = 0; //zerujemy poziom wÄ…tku
    }
}
```
:::info
![](https://i.imgur.com/A2j2Pzl.png)
:::

SW - sekcja wejÅ›ciowa (instrukcje przypisania `level[me]` i `victim[i]`)
ZaÅ‚Ã³Å¼my, Å¼e uruchamiamy algorytm z uÅ¼yciem 3 wÄ…tkÃ³w

me = ThreadID.get();

---

1. WÄ…tek 1 wchodzi do `lock` i wykonuje SW (`level[me] = 1`, `victim[1] = me`) i zostaje wywÅ‚aszczony
2. W wÄ…tku 2 to samo co w kroku 1., jest ustawiony jako `victim`, zostaje wywÅ‚aszczony
3. W wÄ…tku 3 to samo co w kroku 2., jest ustawiony jako `victim`, zostaje wywÅ‚aszczony
4. WÄ…tek 2 zostaje kontynuowany, wchodzi na wyÅ¼szy poziom (`victim[1] = 3`). Warunek czekania w pÄ™tli `while` (linijka 21) nie jest speÅ‚niony, wiÄ™c moÅ¼e przejÅ›Ä‡ przez wszystkie nastÄ™pne poziomy, co teÅ¼ mu siÄ™ udaje i wchodzi do CS. Po wykonaniu znÃ³w wykonuje `lock()`. Jest ustawiony jako `victim` i zostaje wywÅ‚aszczony.
5. W wÄ…tku 3 to samo co w kroku 4.

MoÅ¼e wystÄ…piÄ‡ sytuacja taka, Å¼e kroki 4 i 5 bÄ™dÄ… powtarzaÅ‚y siÄ™ dowolnÄ… liczbÄ™ razy, zwiÄ™kszajÄ…c liczbÄ™ udanych wejÅ›Ä‡ na wyÅ¼szy poziom dla wÄ…tkÃ³w 2 i 3, i nie zmieniajÄ…c dla wÄ…tku 1, zatem ta rÃ³Å¼nica dla wÄ…tku 1 i ktÃ³regoÅ› z wÄ…tkÃ³w 2 i 3 moÅ¼e byÄ‡ dowolnie duÅ¼a, nie istnieje taka staÅ‚a $r$, Å¼e operacja przejÅ›cia na kolejny poziom ma wÅ‚asnoÅ›Ä‡ $r$-ograniczonego czekania

Niech $LU$ oznacza osiÄ…gniÄ™cie nowego poziomu

$D_0^0 \rightarrow D_1^0 \rightarrow D_2^0 \rightarrow LU_1^0 \rightarrow D_1^1 \rightarrow LU_2^0 \rightarrow D_2^1 \rightarrow \dots \rightarrow  D_1^r \rightarrow D_2^r \rightarrow LU_1^r \rightarrow LU_0^0$

z czego mamy

$D_0^0 \rightarrow D_1^0$
$LU_1^r \rightarrow LU_0^0$

## Zadanie 4
:::success
Autor: Wiktor Bukowski		
:::
### 1. 
```java=
public void lock() {
 flag[i] = true; 
 victim = i;
 while (flag[j] && victim == i) {};
}
public void unlock() {
 flag[i] = false; 
}
```

Oznaczmy jako A ten z wÄ…tkÃ³w, ktÃ³ry jako pierwszy wykonaÅ‚ sekcjÄ™ wejÅ›ciowÄ…. Drugi z nich oznaczmy jako B. ZaÅ‚Ã³Å¼my, Å¼e B jako pierwszy wykonaÅ‚ sekcjÄ™ krytycznÄ….
$D_A \rightarrow D_B$
$CS_B \rightarrow CS_A$
$D_A \rightarrow W_A \rightarrow CS_A$
$D_B \rightarrow W_B \rightarrow CS_B$
Wtedy z przechodnioÅ›ci $\rightarrow$:
$D_A \rightarrow D_B \rightarrow CS_B \rightarrow CS_A$

JeÅ›li B jako drugi wykonaÅ‚ sekcjÄ™ wejÅ›ciowÄ…, to ustawiÅ‚ zmiennÄ… `victim` na samego siebie, przez co musiaÅ‚ potem czekaÄ‡ w sekcji oczekiwania do wykonania przez A sekcji krytycznej i zmiany jego flagi. W zwiÄ…zku z tym B nie mÃ³gÅ‚ wykonaÄ‡ sekcji krytycznej przed A.

### 2. 
Ustalmy, Å¼e wÄ…tek A jako pierwszy wykonaÅ‚ ustawienie flagi. Natomiast niech wÄ…tek B jako pierwszy wykona ustawienie zmiennej `victim`. NastÄ™pnie wÄ…tek A nadpisze tÄ™ zmiennÄ…, dziÄ™ki czemu B bÄ™dzie mÃ³gÅ‚ wejÅ›Ä‡ do sekcji krytycznej.

### 3.

#### a) 
Oba wÄ…tki odczytajÄ… to samo niezaleÅ¼nie od kolejnoÅ›ci, a wiÄ™c nie ma moÅ¼liwoÅ›ci rozrÃ³Å¼nienia, ktÃ³ry tak naprawdÄ™ wykonaÅ‚ tÄ™ instrukcjÄ™ szybciej.

### b)
JeÅ›li oba zapisy nastÄ…piÄ… jeden po drugim, a dopiero potem oba wÄ…tki przejdÄ… do kolejnych instrukcji, to nie do rozrÃ³Å¼nienia bÄ™dzie, ktÃ³ry wÄ…tek jako pierwszy zapisaÅ‚ do swojej komÃ³rki.

### c)
Gdy drugi wÄ…tek nadpisze wspÃ³lnÄ… komÃ³rkÄ™, stan zamka bÄ™dzie nierozrÃ³Å¼nialny ze stanem, w ktÃ³rym pierwszy wÄ…tek w ogÃ³le nie prÃ³bowaÅ‚ zdobyÄ‡ blokady. W zwiÄ…zku z tym wÄ…tek drugi moÅ¼e caÅ‚y czas wykonywaÄ‡ instrukcje i dostaÄ‡ siÄ™ do sekcji krytycznej.


## Zadanie 5
:::success
Autor:	Mateusz Kisiel	
:::
![](https://i.imgur.com/j0fXBmE.png)

![](https://i.imgur.com/ZORA9NN.png)

Sekwencyjny porzÄ…dek:
```
r.write(1)
r.read(1)
r.write(2)
r.read(2)
```
![](https://i.imgur.com/OhDvX9e.png)
Sekwencyjny porzÄ…dek:
```
r.write(2)
r.write(1)
r.read(1)
r.read(1)
```
![](https://i.imgur.com/4VN6gqu.png)
Po wykonaniu jako pierwsze `p.enq(x)` nie moÅ¼e zostaÄ‡ zwrÃ³cone y z `p.deq()`

![](https://i.imgur.com/afcnVu8.png)


## Zadanie 6
:::success
Autor:	Marcin WrÃ³bel	
:::
![](https://i.imgur.com/HMRxnFI.png)

![](https://i.imgur.com/CgZZTyf.png)


### Diagram 1
![](https://i.imgur.com/7eKm97d.png)
Historia H
```
B r.write(1) 
A r.read()
C r.write(2)
A r: 1
C r: void
B r: void
B r.read()
B r: 2
```

Legalna sekwencyjna historia S
```
B r.write(1)
B r: void
A r.read()
A r: 1
C r.write(2)
C r: void
B r.read()
B r: 2
```

$\rightarrow_H=$
$\{r.read(1) \rightarrow r.read(2)$
$r.write(1) \rightarrow r.read(2)$
$r.write(2) \rightarrow r.read(2)\}$

$\rightarrow_S=$
$\{r.write(1) \rightarrow r.read(1)$
$r.read(1) \rightarrow r.write(2)$
$r.write(2) \rightarrow r.read(2)\}$

### Diagram 2
![](https://i.imgur.com/OKRPxxM.png)
Historia H
```
B r.write(1)
A r.read()
C r.write(2)
A r: 1
C r: void
B r: void
B r.read()
B r: 1
```

Legalna sekwencyjna historia S
```
C r.write(2)
C r: void
B r.write(1)
B r: void
A r.read()
A r: 1
B r.read()
B r: 1
```

$\rightarrow_H=$
$\{p.read(1) \rightarrow r.read(1)$
$p.write(1) \rightarrow r.read(1)$
$p.write(2) \rightarrow r.read(1)\}$


$\rightarrow_S=$
$\{r.write(2) \rightarrow r.write(1)$
$r.write(1) \rightarrow r.read(1)$
$r.read(1) \rightarrow r.read(1)\}$

### Diagram 3
![](https://i.imgur.com/TlK9Adc.png)


Historia H
```
A p.enq(x)
A p: void
B p.enq(y)
B p: void
A p.deq()
A p: y
```

Historia H nie odpowiada Å¼adnej legalnej sekwencyjnej historii S, poniewaÅ¼ 
mamy $p.enq(x) \rightarrow p.enq(y) \rightarrow p.deq(y)$
Po wykonaniu $p.enq(y)$ kolejka bÄ™dzie zawieraÄ‡ x jako pierwszy element, wiÄ™c p.deq() zwrÃ³ci x, a nie y.

$\rightarrow_H=$
$\{p.enq(x) \rightarrow p.enq(y)$
$p.enq(y) \rightarrow p.deq(y)\}$
### Diagram 4
![](https://i.imgur.com/pOFDmcY.png)

Historia H
```
A p.enq(x)
A p: void
B q.enq(y)
B q: void
A q.enq(x)
A q: void
B p.enq(y)
B p: void
A p.deq()
A p: y
B q.deq()
B q: x
```

Historia H nie odpowiada Å¼adnej legalnej sekwencyjnej historii S, poniewaÅ¼ 
mamy $p.enq(x) \rightarrow p.enq(y) \rightarrow p.deq(y)$
Po wykonaniu $p.enq(y)$ kolejka bÄ™dzie zawieraÄ‡ x jako pierwszy element, wiÄ™c p.deq() zwrÃ³ci x, a nie y.

$\rightarrow_H=$
$\{p.enq(x) \rightarrow q.enq(y)$
$q.enq(y) \rightarrow q.enq(x)$
$q.enq(x) \rightarrow p.enq(y)$
$p.enq(y) \rightarrow p.deq(y)$
$p.deq(y) \rightarrow q.deq(x)\}$

========

# L4 GRUPA 2


## Zadanie 1
:::success
Autor:	Patryk Mazur	
:::
![](https://i.imgur.com/nZXYHuN.png)
![](https://i.imgur.com/Ze1Cswc.png)

Lemat:
Dla $i$ (od $0$ do $n-1$) jest co najwyÅ¼ej $n-i$ wÄ…tkÃ³w na poziomie $i$.

DowÃ³d indukcyjny po poziomach:

Przypadek bazowy:

Na poziomie $0$ jest $n-0$ wÄ…tkÃ³w

Krok Indukcyjny

Z zaÅ‚oÅ¼enia indukcyjnego
Na poziomie $i-1$ jest co najwyÅ¼ej $n-i+1$ wÄ…tkÃ³w

ZaÅ‚Ã³Å¼my nie wprost, Å¼e na poziomie $i$ jest $n-i+1$ wÄ…tkÃ³w

Niech $A$ bÄ™dzie ostatnim wÄ…tkiem na poziomie $i$, ktÃ³ry ustawiÅ‚ $victim[i]$
Zatem dla kaÅ¼dego $B$ na poziomie $i$ nastÄ™puje:

$$write_B(victim[i]) \rightarrow write_A(victim[i])$$

Z kodu:

$$write_b(level[B] = i) \rightarrow write_B(victim[i]) \rightarrow write_A(victim[i])$$

$$write_b(level[B] = i) \rightarrow write_B(victim[i]) \rightarrow write_A(victim[i]) \rightarrow read_A(level[B])$$

Za kaÅ¼dym razem, gdy $A$ odczytuje $level[B]$ widzi wartoÅ›Ä‡ wiÄ™kszÄ… lub rÃ³wnÄ… $i$ (PoniewaÅ¼ $B$ jest na poziomie $i$)
Zatem $A$ nie mogÅ‚oby opuÅ›ciÄ‡ pÄ™tli, co przeczy z naszym zaÅ‚oÅ¼eniem.

Skoro na poziomie $n - i$ znajduje siÄ™ jednoczeÅ›nie co najwyÅ¼ej $i$ wÄ…tkÃ³w, a sekcja krytyczna jest poziomem $n-1$. To znaczy Å¼e algorytm speÅ‚nia warunek wzajemnego wykluczenia. 
($n-(n-1)=1$)


## Zadanie 2
:::success
Autor:	Daniel Boguszewski	
:::
![](https://i.imgur.com/V89b8eW.png)

NiezagÅ‚odzenie: JeÅ›li wÄ…tek prÃ³buje wejÅ›Ä‡ do SK, zrobi to w skoÅ„czonym czasie
ZaÅ‚Ã³Å¼my, Å¼e wÄ…tek $k$ zamierza wejÅ›Ä‡ do SK. Z definicji metody $lock$, znajdzie siÄ™ na jednym z poziomÃ³w $1..n-1$.
JeÅ›li na wyÅ¼szych poziomach nie znajduje siÄ™ Å¼aden wÄ…tek, wtedy $k$ przechodzi wyÅ¼ej (wÄ…tki bÄ™dÄ…ce wyÅ¼ej majÄ… swego rodzaju pierwszeÅ„stwo). W innym wypadku czeka, aÅ¼ przestanie byÄ‡ ofiarÄ… (inny wÄ…tek wejdzie na dany poziom), w zaleÅ¼noÅ›ci od tego, co siÄ™ stanie szybciej.
Po pewnym czasie wÄ…tek $k$ bÄ™dzie musiaÅ‚ przejÅ›Ä‡ poziom wyÅ¼ej.
PoniewaÅ¼ liczba poziomÃ³w jest ograniczona, wÄ…tek $k$ w koÅ„cu dotrze na poziom $n-1$, a tam bÄ™dzie siÄ™ znajdowaÅ‚ nie wiÄ™cej niÅ¼ 1 inny wÄ…tek, to $k$ na wejÅ›cie do SK z tego poziomu bÄ™dzie czekaÅ‚ nie dÅ‚uÅ¼ej, niÅ¼ czas przebywania aktualnego wÄ…tku w SK. MÃ³gÅ‚by wejÅ›Ä‡ od razu, gdyby SK byÅ‚a wolna. QED.

Niezakleszczenie: Do SK, jeÅ›li jest wolna, zawsze wejdzie pewien wÄ…tek. 
Do poziomu $n-1$ zawsze dociera przynajmniej jeden wÄ…tek, a maksymalnie 2.
Jeden z nich zostaje dopuszczony do SK. QED.

## Zadanie 3
:::success
Autor:	Kamila Goszcz	
:::

![](https://i.imgur.com/RymV9Of.png)

**r-Bounded Waiting**  to gÃ³rne ograniczenie na iloÅ›Ä‡ wÄ…tkÃ³w, ktÃ³re mogÄ… uzyskaÄ‡ dostÄ™p do CS przed wÄ…tkiem A mimo Å¼e same zgÅ‚osiÅ‚y chÄ™Ä‡ uzyskania dostÄ™pu pÃ³Åºniej.

![](https://i.imgur.com/1GVRGKh.png)

WÄ…tki 1, 2, 3 chcÄ… wejÅ›Ä‡ do CS, `victim[1] = 3`, jeden z pozostaÅ‚ych wÄ…tkÃ³w (bez straty ogÃ³lnoÅ›ci zaÅ‚Ã³Å¼my, Å¼e to wÄ…tek 1) dostaje siÄ™ do CS, wychodzi z niej i ponownie chce wejÅ›Ä‡ do CS (`victim[1] = 1`), teraz wÄ…tek 2 moÅ¼e wejÅ›Ä‡ do CS, wyjÅ›Ä‡ i ustawiÄ‡ (`victim[1] = 2`). ZauwaÅ¼my, Å¼e uwolniliÅ›my teraz wÄ…tek 1 z victim. Zatem dopÃ³ki wÄ…tek 3 nie otrzyma czasu procesora to bÄ™dzie przepuszczaÅ‚ na zmianÄ™ wÄ…tki 1 i 2.

ZagÅ‚odzenie jest wtedy, gdy to inne wÄ…tki blokujÄ… dostÄ™p do sekcji krytycznej. W tym wypadku jeÅ¼eli ktÃ³ryÅ› z pozostaÅ‚ych wÄ…tkÃ³w ustawi na siebie zmiennÄ… victim oraz wÄ…tek 3 otrzyma czas procesora to napewno zmieni poziom. 

## Zadanie 4
:::success
Autor:	Daniel WiczoÅ‚ek	
:::

![](https://i.imgur.com/6S5peBs.png)
![](https://i.imgur.com/xNuT1Yx.png)

1. przypomnienie
ZaÅ‚Ã³Å¼my $D_{A}^k â†’ D_{B}^j$
Przypomnienie: $â†’$ zachodzi tylko gdy nienachodzÄ… na siebie.
nastÄ™pnie 
a) 
$readA(flag) â†’ writeB(flag)$ wiÄ™c wykonuje siÄ™ $readA(flag)$ czyli $CS_{A}^k â†’ CS_{B}^j$
b) 
$writeB(flag) â†’ readA(flag)$ ale to oznacza, Å¼e nastÄ…pi $writeB(victim)$, wiÄ™c $readA(victim) \neq A$, wiÄ™c $CS_{A}^k â†’ CS_{B}^j$

2. nie, bo moÅ¼e byÄ‡ tak, Å¼e:

- A: ustawia flagÄ™, (czyli $D_{A}^k â†’ D_{B}^j$) 
- B obie linijki,
- A victim 
- B wchodzi


3. ZaÅ‚Ã³Å¼my nie wprost, Å¼e istnieje.
- **odczyt tej samej komÃ³rki pamiÄ™ci lub rÃ³Å¼nych komÃ³rek, w zaleÅ¼noÅ›ci od wÄ…tku**
    - **a) odczyt tej samej**
        - A odczytaÅ‚ pierwszy wiec wszedl 1szy -- tylko 1 chcial wejsc
        - B odczytaÅ‚ A odczytaÅ‚, stan sie nie zmieniÅ‚ w por. z powyzszym wiÄ™c A wszedl pierwszy, 
        - sprzecznosc z **FCFS**
    - **b) roznych**
        - A odczytaÅ‚ swojÄ… i wszedl -- tylko 1 chcial wejsc
        - B swojÄ… A odczytal swojÄ… stan sie nie zmienil od powyzszego przypadku wiec A wszedl, 
        - sprzecznosc z **FCFS**

- **zapis do rÃ³Å¼nych komÃ³rek**
    - B zapis A zapis B pierwszy wiec wszedl (bo FCFS)
    - A zapis B zapis A wchodzi bo FCFS
    - stan ten sam w obu przypadkach po zapisach, bo rozne komorki wiec oba musza wejsc, 
    - sprzecznosc z **mutex**

- **zapis do tej samej komÃ³rki**
    - A zapis, B zapis A wchodzi
    - B zapis B wchodzi
    - oba ten sam stan wiec w 1. B powinien wejsc 
    - sprzeczne z **mutex**.

4. Nie istnieje algorytm FCFS z tÄ… definicjÄ… sekcji wejÅ›ciowej. W porÃ³wnaniu do oryginalnej definicji skrÃ³ciliÅ›my jÄ… o staÅ‚Ä… liczbÄ™ instr.

## Zadanie 5
:::success
Autor:	Joanna Stachowicz	
:::
![](https://i.imgur.com/RANEzka.png)

![](https://i.imgur.com/QlhhkGT.png)

![](https://i.imgur.com/r3rfIGs.png)

![](https://i.imgur.com/ZXIZRrs.jpg)



## Zadanie 6
:::success
Autor:	Maria Szlasa	
:::

:::info
PowtÃ³rz zadanie 5, tym razem uÅ¼ywajÄ…c formalnej definicji linearyzacji (slajd 132). Dla kaÅ¼dego diagramu zdefiniuj odpowiadajÄ…cÄ… mu historiÄ™ ğ». JeÅ›li to moÅ¼liwe, zdefiniuj historiÄ™ ğº oraz legalnÄ… sekwencyjnÄ… historiÄ™ ğ‘† speÅ‚niajÄ…ce warunki z definicji.
:::

![](https://i.imgur.com/OTieVQj.png)
![](https://i.imgur.com/kSM9uyN.png)


**Linearyzacja** formalna definicja 
* Historia $H$ jest linearyzowalna jeÅ›li moÅ¼e byÄ‡ zmodyfikowana do historii $G$ przez:
    * dodanie 0 lub wiÄ™cej powrotÃ³w do oczekujÄ…cych wywoÅ‚aÅ„
    * usuwanie oczekujÄ…cych wywoÅ‚aÅ„

* Zatem historia $G$ jest rÃ³wnowaÅ¼na wzglÄ™dem legalnej/poprawnej sekwencyjnie historii $S$ takiej, Å¼e $\rightarrow_G {\subset} \rightarrow_S$

***
W naszych przykÅ‚adach nie ma niedokoÅ„czonych wywoÅ‚aÅ„ funkcji, daltego nie bÄ™dziemy rozszerzaÄ‡ H do G.

***
![](https://i.imgur.com/O3vLTth.png)
**Formalnie**
Mamy historie $H$ i rÃ³wnowaÅ¼nÄ… poprawnej sekwencyjnie historii $S$:
```
Historia H      Historia S
B r.write(1)    B r.write(1)
A r.read(1)     B r: void
C r.write(2)    A r.read()
A r: 1          A r: 1
B r: void       C r.write(2)
C r: void       C r: void
B r.read(2)     B r.read()
B r: 2          B r: 2
```

oraz ${\rightarrow}_H \subset \rightarrow_S$
* $\rightarrow_H = \{B.write(1) \rightarrow B.read(2), A.read(1) \rightarrow B.read(2), C.write(2) \rightarrow B.read(2)\}$
* $\rightarrow_S = \{B.write(1) \rightarrow A.read(1) \rightarrow C.write(2) \rightarrow B.read(2)\}$
***

![](https://i.imgur.com/KL5vYth.png)
**Formalnie**
Mamy historie $H$ i rÃ³wnowaÅ¼nÄ… poprawnej sekwencyjnie historii $S$: 
```
Historia H      Historia S
B r.write(1)    C r.write(2)
A r.read(1)     C r: void
C r.write(2)    B r.write(1)
A r: 1          B r: void
C r: void       A r.read()
B r: void       A r: 1
B r.read(1)     B r.read()
B r: 1          B r: 1
```

oraz ${\rightarrow}_H \subset \rightarrow_S$
* $\rightarrow_H = \{C.write(2) \rightarrow B.read(1), B.write(1) \rightarrow B.read(1), A.read(1) \rightarrow B.read(1)\}$
* $\rightarrow_S = \{C.write(2) \rightarrow B.write(1) \rightarrow A.read(1) \rightarrow B.read(1)\}$
***

![](https://i.imgur.com/g1CYP7D.png)
**Formalnie**
Mamy historie $H$, ktÃ³rÄ… nie moÅ¼emy rozszerzyÄ‡ do rÃ³wnowaÅ¼nej poprawnej sekwencyjnie historii $S$, w ktÃ³rej wczeÅ›niej wyciÄ…gamy element $x$ z $p$. 
```
A p.enq(x)
A p: void
B p.enq(y)
B p: void
A p.deq()
A p: y
```

***

![](https://i.imgur.com/6gHGZ1i.png)
**Formalnie**
Mamy historie $H$, ktÃ³rÄ… nie moÅ¼emy rozszerzyÄ‡ do rÃ³wnowaÅ¼nej poprawnej sekwencyjnie historii $S$, w ktÃ³rej instrukcje wykonajÄ… siÄ™ poprawnie.
```
A p.enq(x)
A p: void
B q.enq(y)
B q: void
A q.enq(x)
A q: void
B p.enq(y)
B p: void
A p.deq()
A p: y
B q.deq()
B q: x
```
