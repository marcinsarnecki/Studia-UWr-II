# Ä†wiczenia 8, grupa cz. 10-12, 9. grudnia 2021

###### tags: `PRW21` `Ä‡wiczenia` `pwit`

## Deklaracje

GotowoÅ›Ä‡ rozwiÄ…zania zadania naleÅ¼y wyraziÄ‡ poprzez  postawienie X w odpowiedniej kolumnie! JeÅ›li poÅ¼Ä…dasz zreferowaÄ‡ dane zadanie (co najwyÅ¼ej jedno!) w trakcie dyskusji oznacz je znakiem ==X== na Å¼Ã³Å‚tym tle.

**UWAGA: TabelkÄ™ wolno edytowaÄ‡ tylko wtedy, gdy jest na zielonym tle!**
:::danger
|                        | 1     | 2   | 3   | 4   | 5   | 6   | 7   |
| ----------------------:| ----- | --- | --- | --- | --- | --- | --- |
PrzemysÅ‚aw Hoszowski     |       |  X  |     |     |     |     |  X  |
Dominik KomÅ‚a            |       |  X  |  X  |     |     |     |     |
Tomasz MrÃ³z              |       |     |     |     |     |     |     |
Mateusz Opala            |       |   X  |  X   |     |     |  X   |   X  |
Åukasz Pluta             |       |     |  X   |     |     |     |     |
Antoni PokusiÅ„ski        |       |  X  |     |     |     |     |     |
Szymon Rysz              |       |     |     |     |     |     |     |
Dominik Samorek          |       |     |     |     |     |     |     |
Mateusz SidÅ‚o            |   X   |  X  |     |     |     |     |     |
Jan WaÅ„kowicz            |       |     |     |     |     |     |     | 
MichaÅ‚ ZieliÅ„ski         |       |     |     |     |  X  |     |    |
:::


:::info
**Uwaga:** Po rozwiÄ…zaniu zadania naleÅ¼y zmieniÄ‡ kolor nagÅ‚Ã³wka na zielony.
:::

## Zadanie 1

:::success
Autor: Mateusz SidÅ‚o
:::
:::info
Mamy trzy wÄ…tki: A, B, C oraz rejestry MRSW: XA, XB, XC. KaÅ¼dy wÄ…tek moÅ¼e zapisywaÄ‡ swÃ³j rejestr oraz odczytywaÄ‡ wszystkie z nich. Poza tym, kaÅ¼dej parze wÄ…tkÃ³w przypisujemy rejestr typu RMW (ang. Read Modify Write) udostÄ™pniajÄ…cy atomowÄ… operacjÄ™ `compareAndSet()`. Te rejestry to: RAB, RBC oraz RAC, a uÅ¼ywaÄ‡ ich mogÄ… jedynie wÄ…tki do nich przypisane. WykaÅ¼, Å¼e nie istnieje nieczekajÄ…ca implementacja protokoÅ‚u binarnego konsensusu dla trzech wÄ…tkÃ³w, uÅ¼ywajÄ…ca wyÅ‚Ä…cznie wymienionych wyÅ¼ej zasobÃ³w.
:::

ZaÅ‚Ã³Å¼my, Å¼e mamy nieczekajÄ…cÄ… implementacjÄ™ protokoÅ‚u binarnego konsensusu dla trzech wÄ…tkÃ³w, uÅ¼ywajÄ…ca wyÅ‚Ä…cznie wymienionych wyÅ¼ej zasobÃ³w. RozwaÅ¼my punkt krytyczny. Bez utraty ogÃ³lnoÅ›ci zaÅ‚Ã³Å¼my, Å¼e nastÄ™pna wykonana przez A instrukcja wprowadza nas w stan 0-walentny, a nastÄ™pna wykonana przez B wprowadza nas w stan 1-walentny. Punktem krytycznym moÅ¼e byÄ‡ jedynie sytuacja w ktÃ³rej dwa wÄ…tki wykonujÄ… operacjÄ™ na tym samym obiekcie.

1. 2x read() na obiekcie rejestru MRSW. Nie moÅ¼e byÄ‡ stanem krytycznym.

2. write() i read() na obiekcie rejestru MRSW. Nie moÅ¼e byÄ‡ stanem krytycznym.

![](https://i.imgur.com/p8vMAf9.png)

3. compareAndSet() na obiekcie rejestru RMW. 

    Rozpatrzmy nastÄ™pujÄ…cy stan krytyczny. WeÅºmy wÄ…tki A i B, oraz rejestr RAB. A i B wykonujÄ… operacjÄ™ cAS. Nie moÅ¼e byÄ‡ stanem krytycznym.
    
![](https://i.imgur.com/vzbQ0pH.png)

## Zadanie 2

:::success
Autor: Antoni PokusiÅ„ski
:::
```java=
FIRST = -1;
int decide(int v) {
    propose(v);
    int i = getID();
    // double_cAS(r1, r2, expected, update)
    if (double_CAS(myreg1, myreg2, FIRST, i)) {
        return proposed[i]
    }
    else {
        if (myreg1.get() != -1)
            return proposed[myreg1.get()];
        return proposed[myreg2.get()];
    }
}
```
## Zadanie 3

:::success
Autor: Dominik KomÅ‚a
:::

```
Zadanie 3. Definiujemy n-ograniczonÄ… funkcjÄ™ compareAndSet(r,
expected, update) tak: pierwszych n wywoÅ‚aÅ„ funkcji na
rejestrze r ma semantykÄ™ takÄ… samÄ…, jak standardowa funkcja
compareAndSet(), w szczegÃ³lnoÅ›ci wartoÅ›ciami zwracanymi sÄ…
true lub false, zaleÅ¼nie od wykonania aktualizacji rejestru.
NastÄ™pne wywoÅ‚ania funkcji wprowadzajÄ… rejestr r w stan
wadliwy, co sprawia Å¼e wartoÅ›ciÄ… zwracanÄ… jest âŠ¥. PokaÅ¼, Å¼e
poziom konsensusu n-ograniczonej funkcji compareAndSet() dla
ğ‘› â‰¥ 2 to dokÅ‚adnie n.
```





```
Da siÄ™ dla n wÄ…tkÃ³w.
```

Bardzo Å‚atwo moÅ¼emy pokazaÄ‡, Å¼e da siÄ™ to zrobiÄ‡ dla n wÄ…tkÃ³w. Po prostu stosujemy algorytm z wykÅ‚adu.

```
Nie da siÄ™ dla n+1 wÄ…tkÃ³w.
```

ZauwaÅ¼my, Å¼e tylko n wÄ…tkÃ³w moÅ¼e uÅ¼yÄ‡ funkcji compare_and_set. N+1szy wÄ…tek nie moÅ¼e jej juÅ¼ uÅ¼yÄ‡. MoÅ¼emy teraz zauwaÅ¼yÄ‡, Å¼e mamy n wÄ…tkÃ³w, ktÃ³re wykonaÅ‚y compare_and_set i jeden, ktÃ³ry nie moÅ¼e tego wykonaÄ‡. Ta sytuacja jest analogiczna, do prÃ³by wykonania konsensusu dla 2 wÄ…tkÃ³w jedynie za pomocÄ… rejestrÃ³w atomowych. A jak wiadomo, nie da siÄ™ tego zrobiÄ‡.
## Zadanie 4

:::danger
Autor: PWit
:::


:::info
Podaj nieczekajÄ…cÄ… implementacjÄ™ dwuwÄ…tkowego
obiektu 2/3-przypisania (tablica ma 3 elementy, kaÅ¼dy wÄ…tek
zapisuje ustalone 2 z nich) uÅ¼ywajÄ…c trzech obiektÃ³w
(rejestrÃ³w) oferujÄ…cych funkcje compareAndSet() oraz get()
oraz (ewentualnie) rejestrÃ³w atomowych MRMW.
:::


```java=
public class Assign23<T> {
    AtomicReference<T> [] r  = (AtomicReference <T> []) new Object [3];
    
    public Assign23(T init) {
        for(int i =0; i < r.length; i++)
            r[i] =  new AtomicRefernce<T>(init);
        
    }
    
    public void assign (T v0, T v1, int ind0, int ind1) {
        
        T t0 = r[ind0].get(); /*pierwszy etap*/
        T t1 = r[ind1].get();
 
        r[ind0].compareAndSet(t0,v0); /*drugi etap*/
        r[ind1].compareandSet(t1,v1);
        
    }
    
    public T read(int index) {
        return r[index].get()
    }    
    
}

```

Analiza funkcji ``assign``. SÄ… trzy przypadki:

* obydwa wywoÅ‚ania `compareAndSet` powiodÅ‚y siÄ™. WÄ…tek woÅ‚ajÄ…cy `assign` atomowo zmieniÅ‚ zawartoÅ›Ä‡ obydwu pÃ³l tablicy.
* obydwa wywoÅ‚ania `compareandSet` zawiodÅ‚y. To oznacza, Å¼e wartoÅ›ci zapisane w tablicy pod indeksami ind0 i ind1 zmieniÅ‚y siÄ™ pomiÄ™dzy etapem pierwszym a drugim. Czyli wspÃ³Å‚bieÅ¼nie z obecnym wywoÅ‚aniem assign dziaaÅ‚o wywoÅ‚anie tej metody przez drugi wÄ…tek. MoÅ¼na zatem zlinearyzowaÄ‡ te wywoÅ‚ania tak, by wywÅ‚oÅ‚anie tej metody przez wÄ…tek drugi byÅ‚o pÃ³Åºniejsze niÅ¼ wywoÅ‚anie obecnie analizowane. Obecne wywoÅ‚anie assign dziaÅ‚a tak, jak gdyby atomowo zmieniÅ‚o obydwa rejestry, ale zostaÅ‚o od razu nadpisane przez assign drugiego wÄ…tku.
* jedno z wywoÅ‚aÅ„ `compareAndSet` powiodÅ‚o siÄ™ a drugie zawiodÅ‚o. To oznacza, Å¼e obydwa wÄ…tki majÄ… tylko jeden wspÃ³lnie modyfikowany indeks w tablicy. Podobnie jak w punkcie poprzednim to oznacza, Å¼e dwa wywoÅ‚ania `assign` dziaÅ‚ajÄ… wspÃ³Å‚bieÅ¼nie. Wybieramy punkt linearyzacji tego drugiego tak, by byÅ‚ pÃ³Åºniejszy niÅ¼ punkt linearyzacji obecnego wywoÅ‚ania. W efekcie `assign` dziaÅ‚a tak, jak gdyby atomowo zmieniÅ‚o wartoÅ›Ä‡ pÃ³l o indeksach ind0 i ind1 i byÅ‚o zaraz nadpisane przez to drugie wspÃ³Å‚bieÅ¼ne wywoÅ‚anie. 





## Zadanie 5

:::success
Autor: MichaÅ‚ ZieliÅ„ski
:::

### TreÅ›Ä‡
RozwaÅ¼my nastÄ™pujÄ…cy dwuwÄ…tkowy obiekt QuasiConsensus z metodÄ… decide(v), gdzie v jest wartoÅ›ciÄ… binarnÄ…. JeÅ›li obydwa wÄ…tki, A i B,  wywoÅ‚aÅ‚y decide() z tÄ… samÄ… wartoÅ›ciÄ… v, to wspÃ³lnie uzgodnionÄ… wartoÅ›ciÄ… jest v â€” decide() zwraca v. JeÅ›li wÄ…tki wywoÅ‚aÅ‚y decide() z rÃ³Å¼nymi argumentami to albo muszÄ… uzgodniÄ‡ jednÄ… z nich, albo B otrzyma wartoÅ›Ä‡ 0 i A otrzyma wartoÅ›Ä‡ 1 (ale nie na odwrÃ³t).
DokÅ‚adnie jedno z poniÅ¼szych zadaÅ„ ma rozwiÄ…zanie. Wybierz odpowiednie i rozwiÄ…Å¼ je.
1. PokaÅ¼, Å¼e poziom konsensusu dla obiektÃ³w QuasiConsensus
jest . Tzn. zaimplementuj dwuwÄ…tkowy protokÃ³Å‚â‰¥2
konsensusu uÅ¼ywajÄ…c obiektÃ³w QuasiConsensus i rejestrÃ³w
atomowych.
2. PokaÅ¼, Å¼e poziom konsensusu dla obiektÃ³w QuasiConsensus
wynosi 1.
### RozwiÄ…zanie
Wiemy, Å¼e istnieje stan krytyczny. RozwaÅ¼my przypadki:
#### A - decide(0), B - decide(0)
Mamy te same argumenty, wiÄ™c ustalone zostanie 0. B nie wie czy A miaÅ‚o jako argument 1 czy 0.
#### A - decide(1), B - decide(1)
Mamy te same argumenty, wiÄ™c ustalone zostanie 1.
#### A - decide(1), B - decide(0)
A nie jest w stanie odrÃ³Å¼niÄ‡ tej sytuacji, od tej w ktÃ³rej B - decide(1) (w ktorej zwrocone byÅ‚oby 1)
#### A - decide(0), B - decide(1)
Jezeli A proponuje 1, A nie odrÃ³Å¼nia sytuacji, gdy B dostanie do wskazania 1 i 0.
## Zadanie 6

:::success
Autor: Mateusz Opala
:::

Rozpatrzmy drzewo stanÃ³w z dowodu niemoÅ¼liwoÅ›ci skonstruowania binarnego konsensusu przy pomocy jedynie rejestrÃ³w. W tym dowodzie korzystaliÅ›my z wÅ‚asnoÅ›ci wait-free jedynie w celu pokazania, Å¼e dojdziemy do stanu krytycznego, a w zasadzie jedynie, Å¼e nie pozostaniemy w pewnym niekrytycznym stanie biwalentnym nieskoÅ„czenie dÅ‚ugo. Niewstrzymywanie gwarantuje nam dokÅ‚adnie tÄ… samÄ… wÅ‚aÅ›noÅ›Ä‡. Z jej definicji nigdy nie bÄ™dziemy w Å¼adnym stanie przez nieskoÅ„czenie dÅ‚ugo czasu. Reszta dowodu jest identyczna jak w przypadku wait-free.

## Zadanie 7

:::success
Autor: PrzemysÅ‚aw Hoszowski
:::
Zadanie 4 z listy 7
```java=
public class ConsensusProposal {
    Boolean proposed[] = new Boolean[2];
    Integer[] speed = new Integer[2];
    Integer[] position = new Integer[2];
    
    public ConsensusProposal(){
        position[0] = 0;
        position[1] = 0;
        speed[0] = 3;
        speed[1] = 1;
    }
    
    public Boolean decide(Boolean value) {
        int i = ThreadID.get(); //0 or 1
        int j = 1 - i;
        proposed[i] = value;
        
        while (true) {
            position[i] = position[i] + speed[i];
            if (position[i] > position[j] + speed[j]) // I am far ahead of you
                return proposed[i];
            else if (position[i] < position[j]) // I am behind you
                return proposed[j];
        }
    }
}
```
PoprawnoÅ›Ä‡ algorytmu konsensusu byÅ‚a udowodniona na poprzedniej liÅ›cie.

Korzystamy tylko z rejestrÃ³w atomowych, wiÄ™c nie mamy algorytmu wait-free.

ZauwaÅ¼my, Å¼e jak wÄ…tek bÄ™dzie w metodzie w izolacji to po maksymalnie kilku obrotach pÄ™tli zwrÃ³ci on wartoÅ›Ä‡. Jest wiÄ™c niehamowana, a nie nieczekajÄ…ca.