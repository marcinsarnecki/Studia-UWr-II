# wiczenia 5, grupa cz. 10-12, 18. listopada 2021

###### tags: `PRW21` `wiczenia` `pwit`

## Deklaracje

Gotowo rozwizania zadania nale偶y wyrazi poprzez postawienie X w odpowiedniej kolumnie! Jeli po偶dasz zreferowa dane zadanie (co najwy偶ej jedno!) w trakcie dyskusji oznacz je znakiem ==X== na 偶贸tym tle.

**UWAGA: Tabelk wolno edytowa tylko wtedy, gdy jest na zielonym tle!**
:::danger
|                        | 1     | 2   | 3   | 4   | 5   | 6   | 7   |
| ----------------------:| ----- | --- | --- | --- | --- | --- | --- |
Dominik Budzki           |       |     |     |     |     |     |     |
Przemysaw Hoszowski     |       |  X  |  X  |  X  |  X  |     |  X  |
Dominik Koma            |   X   |  X  |  X  |  X  |  X  |  X  |  X  |
Tomasz Mr贸z              |       |     |     |     |     |     |     |
Mateusz Opala            |    X   |  X   |  X   |  X   |  X   |  X   |  X   |
ukasz Pluta             |    X   |   X  |  X   |   X  |   X  |   X  | X    |
Antoni Pokusiski        |       |  X  |   X |  X  |  X  |     |  X  |
Szymon Rysz              |   X   |  X  |==X==|  X  |  X  |    |  X  |
Dominik Samorek          |       |     |     |     |     |     |     |
Mateusz Sido            |    X  |  X  |  X  |  X  |     |     |  X  |
Mateusz Szwelengreber    |       |     |     |     |     |     |     |
Jan Wakowicz            |   X   |  X  |  X  |  X  |  X  |  X  |  X  |
Micha Zieliski         |   X   |==X==|  X  |  X  |     |     |     |
:::




:::info
**Uwaga:** Po rozwizaniu zadania nale偶y zmieni kolor nag贸wka na zielony.
:::

## Zadanie 1
:::success
Autor: Mateusz Sido
:::

Algorytm implementujcy zamek nazywamy *First-Come-First-Served* (FCFS), gdy dla ka偶dego systemu zo偶onego z przynajmniej dw贸ch wtk贸w A i B, jeli $_A^j\rightarrow D_B^k$ to $CS_A^j\rightarrow CS_B^k$, gdzie $D_C^i$ oraz $CS_C^i$ oznaczaj odpowiednio i-te wykonanie sekcji wejciowej algorytmu oraz i-te zajcie zamka przez wtek C. Intuicyjnie oznacza to, 偶e jeli A zakoczy wykonanie sekcji wejciowej zanim zrobi to B, to A we藕mie zamek zanim zrobi to B. 

Pokazalimy, 偶e algorytm Petersona jest FCFS gdy za sekcj wejciow przyj kilka pierwszych instrukcji metody `lock()`, a dokadniej instrukcje odczytu numeru wtku oraz ustawiania flag i ofiary. Zmiemy teraz definicj sekcji wejciowej tak, by oznaczaa po prostu pierwsz instrukcj metody `lock()`.

1. Poka偶, 偶e 偶aden z poni偶szych wariant贸w algorytmu Petersona nie jest FCFS przy tak zmienionej definicji sekcji wejciowej:
    a. pierwsz instrukcj algorytmu jest odczyt numeru wtku: `i = Thread.getID()`, gdzie i jest zmienn lokaln wtku,
    
    ```java=
    public void lock() {
        int i = Thread.getID(); //D 
        
        flag[i] = true; //
        victim = i;     // S
        int j = 1 - i;  //
        
        while (flag[j] && victim == i) {};
    }

    public void unlock() {
        flag[i] = false;
    }
    ```
    Za贸偶my, 偶e:
    $$
        D_0^i \rightarrow D_1^j\\
        S_1^j \rightarrow S_0^i 
    $$
    Wtedy:
    $$
        CS_1^j \rightarrow CS_0^i
    $$
    
    b. pierwsz instrukcj jest ustawienie flagi: `flag[Thread.getID()] = true`,
    
    ```java=
    public void lock() {
        flag[Thread.getID()] = true; //D 
        
        int i = Thread.getID(); //
        victim = i;             // S
        int j = 1 - i;          //
        
        while (flag[j] && victim == i) {};
    }

    public void unlock() {
        flag[i] = false;
    }
    ```
    Za贸偶my, 偶e:
    $$
        D_0^i \rightarrow D_1^j\\
        S_1^j \rightarrow S_0^i 
    $$
    Wtedy:
    $$
        CS_1^j \rightarrow CS_0^i
    $$
    
    c. pierwsz instrukcj jest ustawienie ofiary:   `victim = Thread.getID()`, czyli instrukcje ustawiania flag i ofiary s w odwr贸conej kolejnoci w stosunku do oryginalnego algorytmu.
    
       
    ```java=
    public void lock() {
        victim = Thread.getID(); //D 
        
        int i = Thread.getID(); //
        flag[i] = true;         // S
        int j = 1 - i;          //
        
        while (flag[j] && victim == i) {};
    }

    public void unlock() {
        flag[i] = false;
    }
    ```
    
    Za贸偶my, 偶e:
    $$
        D_0^i \rightarrow D_1^j\\
        S_1^j \rightarrow S_0^i 
    $$
    Wtedy:
    $$
        CS_1^j \rightarrow CS_0^i
    $$
    
    
> [name=Piotr Witkowski] Powy偶szy kod nie ma wasnoci wzajmnego wykluczania (m贸j bd). Dlatego lepiej jest rozwa偶y taki kod:

    ```java=
    public void lock() {
        
        foo = Thread.getID(); // D (foo jest zmienn wsp贸dzielon, kt贸ra wystpuje tylko w tym wierszu algorytmu)

        int i = Thread.getID(); //
        flag[i] = true; //
        victim = i;     // S
        int j = 1 - i;  //
        
        while (flag[j] && victim == i) {};
    }

    public void unlock() {
        flag[i] = false;
    }
    ```

    
    
    
2. Wywnioskuj std, 偶e 偶aden algorytm implementujcy zamek (wzajemne wykluczanie) i zachowujcy warunek niezagodzenia nie jest FCFS, jeli sekcja wejciowa to pierwsza instrukcja metody `lock()`.
     
> [name=Piotr Witkowski] Odpowiadajc na poni偶sze pytania nale偶y posu偶y si pojciem stan systemu. Np. w pkcie a: stan systemu po wykonaniu najpierw sekcji wejciowej wtku A a p贸藕niej sekcji wejciowej wtku B jest nieodr贸偶nialny (jest taki sam) od stanu systemu w kt贸rym te sekcje wykonay si w odwrotnej kolejnoci. A zatem system "nie wie" w jakiej kolejnoci ma wpuci wtki do sekcji krytycznej.
> 

    
     
     a. odczytem tej samej kom贸rki lub r贸偶nych kom贸rek pamici w zale偶noci od wtku, 
         
     Kolejnoc wejcia do sekcji krytycznych zale偶y od tego, co zostao odczytane oraz od kolejnych instrukcji.
     
     b. zapisem do r贸偶nych kom贸rek,
     
     Do r贸偶nych kom贸rek zapisywana jest jak z g贸ry znana liczba. Je偶eli w kolejnych krokach nie nastpi zapis do innych miejsc w pamici, to algorytm nie spenia wasnoci niezagodzenia. Je偶el nastpi to kolejno wykonywania sekcji krytycznej zale偶y od kolejnoci zapis贸w do innych kom贸rek w pamici.
     
     c. zapisem do tej samej kom贸rki.
     
     Jedna kom贸rka pamici jestnie wystarczjca do zagwarantowania wzajemnego wykluczenia, a zatam wtki musz dokona zapisu do innych kom贸rek pamici i kolejno tego zapisu ma wpyw na kolejno dostpu do sekcji krytycznej.

Wersja poprawiona:
     
 a. odczytem tej samej kom贸rki lub r贸偶nych kom贸rek pamici w zale偶noci od wtku, 

 Odczytanie wartoci z pamici nie ma wpywu na stan systemu, a zatem taka sytuacja w kt贸rej $D_A \rightarrow D_B$ jest nieodr贸偶nialna od $D_B \rightarrow D_A$. System "nie wie", kt贸ry wtek powinien jako pierwszy wej do sekcji krytycznej.

 b. zapisem do r贸偶nych kom贸rek,

 Do r贸偶nych kom贸rek zapisywane s jakie z g贸ry znane wartoci. Stan systemu w sytuacji w kt贸rej $D_A \rightarrow D_B$ jest nieodr贸偶nialny od $D_B \rightarrow D_A$, bo niezale偶nie od tego, kt贸ry wtek jako pierwszy wykona swoj sekcj wejciow, to w pamici bd zapisane te same wartoci. System "nie wie", kt贸ry wtek powinien jako pierwszy wej do sekcji krytycznej.

 c. zapisem do tej samej kom贸rki.

 Stan systemu w sytuacji w kt贸rej mamy dwa wtki, dla kt贸rych $D_A \rightarrow D_B$ jest nieodr贸znialna od sytuacji w kt贸rej mamy tylko wtek $B$. Jako, 偶e system spenia wasno niezagodzenia, to w obu przypadkach wtek $B$ jako pierwszy powinien wykona swoj sekcj krytyczn.

## Zadanie 2
:::success
Autor: Micha Zieliski
:::

### Tre
Poka偶, 偶e sekwencyjna sp贸jno nie ma wasnoci kompozycji.
### Rozwizanie
We藕my taki cig zdarze dla kolejek FIFO p i q:
1 A p.enq(x)
2 B q.enq(y)
3 A q.enq(x)
4 B p.enq(y)
5 A p.deq() (y)
6 B q.deq() (x)

Dla poszczeg贸lnych wtk贸w mamy kolejno 1-3-5 i 2-4-6 (dla wtk贸w zachodzi sp贸jno sekwencyjna).

Patrzc na kolejki, musimy mie 4-1-5 i 3-2-6.

Nie mo偶emy uzyska takiej "kompozycji", 偶eby dao si zachowa sp贸jno.

## Zadanie 3
:::success
Autor: Szymon Rysz
:::
![](https://i.imgur.com/ACU6mxO.png)

![](https://i.imgur.com/FP7IbOv.png)

![](https://i.imgur.com/MRLija9.png)
![](https://i.imgur.com/Vw80Dhj.png)


Dwa procesy mog pobra warto $flag[j]$ na pocztku $lock()$ -> oba bd przechowyway warto $flag[j] == false$ -> oba wejd do sekcji krytycznej.
## Zadanie 4
:::success
Autor: Antoni Pokusiski
:::

:::info
Z u偶yciem klasy *AtomicInteger* zaprogramowano poni偶sz
implementacj kolejki FIFO, dopuszczajcej wiele wtk贸w
wkadajcych i wycigajcych elementy. Poka偶, 偶e jest ona
niepoprawna. W tym celu poka偶, 偶e nie jest linearyzowalna.
:::
```java=
class IQueue<T> {
    AtomicInteger head = new AtomicInteger(0);
    AtomicInteger tail = new AtomicInteger(0);
    T[] items = (T[]) new Object[Integer.MAX_VALUE];
    
    public void enq(T x) {
        int slot;
        do {
            slot = tail.get();
        } while (! tail.compareAndSet(slot, slot+1)); // rezerwacja
        items[slot] = x; // dopiero tutaj efekt widoczny dla innych wtk贸w
    }
    
    public T deq() throws EmptyException {
        T value;
        int slot;
        do {
            slot = head.get();
            value = items[slot];
            if (value == null)
                throw new EmptyException();
        }  while (! head.compareAndSet(slot, slot+1));
        return value;
    }
}
```
Problem - w procedurze ```enq()``` operacje ```tail.compareAndSet``` i ```items[slot] = x``` nie s wykonane atomowo. Nieformalnie - mo偶e to doprowadzi do sytuacji, gdy wtek zatrzyma si pomidzy tymi instrukcjami, czyli - zarezerwowa ju偶 miejsce, ale nic do niego nie wstawi. Jeli teraz inny wtek wykona ```enq()```, a potem ```deq()```, to zwr贸ci *EmptyException*, mimo 偶e kolejka nie jest pusta. Formalnie:

```
 A: ---<A.enq(x)................>---
 B: -----<B.enq(y)>---<B.deq()>-----
```
**1.** A.enq(x)
**2.** B.enq(y)
**3.** B: void
**4.** B.deq()
**5.** B: EmptyException
**6.** A: void()

Taka historia nie jest linearyzowalna - ```B.deq()``` wykonuje si po operacji ```B.enq(y)```(czyli mamy gwarancj, 偶e w FIFO znajduje jaki element), a mimo to dostajemy *EmptyException*. Jest to niezgodne z sekwencyjn specyfikacj FIFO.

## Zadanie 5
:::success
Autor: Przemysaw Hoszowski
:::
![](https://i.imgur.com/wlwfR7K.png)
W metodzie enq punkty odpowiadaj instrukcj (pierwszy punkt to pierwsza instrukcja) 
### a)
Dla wykonania:
![](https://i.imgur.com/DIWwbg1.png)
Jeli pierwszy punkt bdzie punktem linearyzacji to otrzymamy kolejno:
```
A enq(0)
B enq(1)
B deq(1)
```
Co jest sprzeczne z oczekiwanym dziaaniem kolejki.
### b)
Dla wykonania:
![](https://i.imgur.com/lX0tdlU.png)
Jeli drugi punkt bdzie punktem linearyzacji to otrzymamy kolejno:
```
B enq(1)
A enq(0)
B deq(0)
```
Co jest sprzeczne z oczekiwanym dziaaniem kolejki.

### Czy z powy偶szych punkt贸w wynika, 偶e enq() nie jest linearyzowalna?

Nie mo偶emy: ![](https://i.imgur.com/gxfiR1o.png)

## Zadanie 6
:::success
Autor: Jan Wakowicz
:::

Sprowad藕my najpierw przedziay, w jakich dziaa nasza funkcja do troch mniejszych. Jeli historia bdzie linearyzowalna dla mniejszych przedzia贸w, to oczywistym jest, 偶e bdzie r贸wnie偶 dla wikszych. 
W tym celu pocztek funkcji enq() ustalamy jako moment wykonania pierwszej instrukcji, a koniec jako moment wykonania drugiej instrukcji. Deq() za skracamy do pojedynczego punktu, kt贸ry odpowiada momentowi, w kt贸rym znajdujemy pierwszy niepusty element. Mo偶emy zauwa偶y, 偶e w tym przypadku mamy dla funkcji deq() jasno wyznaczony punkt linearyzacji. 
Przesortujmy teraz rosnco nasze przedziay deq(x) rosnco po punktach linearyzacji oraz enq(x) rosnco po odpowiadajcych im wywoaniom deq(x). Teraz mo偶emy po prostu po kolei i po przedziaach dla wywoa enq() i jako ich punkt linearyzacji bra pierwszy taki punkt, kt贸ry nie zosta jeszcze wybrany wczeniej. Okazuje si, 偶e zawsze taki istnieje.

#### Dow贸d nie wprost:

Za贸偶my, 偶e istnieje takie wywoanie enq(j), dla kt贸rego nie mo偶emy ju偶 wybra punktu linearyzacji. Jest to r贸wnowa偶ne z tym, 偶e wybralimy dla jakiego wczeniejszego przedziau taki punkt, kt贸ry jest p贸藕niej od koca naszego przedziau. Jeli za zawsze bierzemy najwczeniejszy porpawny punkt, musielimy gdzie wybra taki punkt, kt贸ry znajduje si ma pocztku przedziau i jest p贸藕niej od koca naszego przedziau. Mamy wtedy nastpujc sytuacj:

Lemat:

Jeli istnieje takie j, 偶e nie mo偶emy dla niego wybra punktu linearyzacji, to musi istnie takie i, 偶e enq(j) -> enq(i) -> deq(i) -> deq(j).

![](https://i.imgur.com/lwpp7fP.png)


To jest za sprzeczno, gdy偶 w tym przypadku w wywoaniu program贸w przy pierwszym wywoaniu deq() cignelibymy j zamiast i.


## Zadanie 7
:::success
Autor: ukasz Pluta
:::

Metoda ma wasno wait-free - zawsze wraca po skoczonym czasie (mimo, 偶e ten czas wydu偶a si po ka偶dym wywoaniu funkcji).

Metoda nie ma wlasnoci bounded wait-free, 2^i, i->inf nie da sie ograniczy od g贸ry przez sta.



